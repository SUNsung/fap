
        
                @version_value = '#{major}.#{minor}.#{patch}.#{new_appendix}'
      end
    
        it 'raises an exception when an incorrect path is given' do
      expect do
        Fastlane::Helper::PodspecHelper.new('invalid_podspec')
      end.to raise_error('Could not find podspec file at path 'invalid_podspec'')
    end
    
        def same_platform?(sdkroot)
      destination = Gym.config[:destination].dup
      destination.slice!('generic/platform=')
      destination_sdkroot = []
      case destination
      when 'macosx'
        destination_sdkroot = ['macosx']
      when 'iOS'
        destination_sdkroot = ['iphoneos', 'watchos']
      when 'tvOS'
        destination_sdkroot = ['appletvos']
      end
      return destination_sdkroot.include?(sdkroot)
    end
    
            # Stub Time.now to return current time on first call and 6 minutes later on second
        before { allow(Time).to receive(:now).and_return(time_now, (time_now + 60 * 6)) }
        it 'throws a UI error' do
          allow(fake_app).to receive(:latest_version).and_return(fake_version)
          allow(fake_version).to receive(:candidate_builds).and_return([])
          expect do
            review_submitter.wait_for_build(fake_app, '1.2.3')
          end.to raise_error(FastlaneCore::Interface::FastlaneError, 'Could not find any available candidate builds on App Store Connect to submit')
        end
      end
    
            return File.join(containing, file_name)
      end
    end
  end
end

    
          def self.available_options
        [
          FastlaneCore::ConfigItem.new(key: :xcodeproj,
                             env_name: 'FL_BUILD_NUMBER_PROJECT',
                             description: 'optional, you must specify the path to your main Xcode project if it is not in the project root directory',
                             optional: true,
                             verify_block: proc do |value|
                               UI.user_error!('Please pass the path to the project, not the workspace') if value.end_with?('.xcworkspace')
                               UI.user_error!('Could not find Xcode project') if !File.exist?(value) && !Helper.test?
                             end),
          FastlaneCore::ConfigItem.new(key: :hide_error_when_versioning_disabled,
                             env_name: 'FL_BUILD_NUMBER_HIDE_ERROR_WHEN_VERSIONING_DISABLED',
                             description: 'Used during `fastlane init` to hide the error message',
                             default_value: false,
                             type: Boolean)
        ]
      end
    
          def self.output
        [
          ['IPA_OUTPUT_PATH', 'The path to the newly generated ipa file'],
          ['DSYM_OUTPUT_PATH', 'The path to the dsym file']
        ]
      end
    
          it 'prefers an explicitly specified changelog value' do
        values = Fastlane::FastFile.new.parse('lane :test do
          # changelog_from_git_commits sets this lane context variable
          Actions.lane_context[SharedValues::FL_CHANGELOG] = 'autogenerated changelog'
          pilot(changelog: 'custom changelog')
        end').runner.execute(:test)
    
            # distribution
        FastlaneCore::ConfigItem.new(key: :uses_non_exempt_encryption,
                                     short_option: '-X',
                                     env_name: 'PILOT_USES_NON_EXEMPT_ENCRYPTION',
                                     description: 'Provide the 'Uses Non-Exempt Encryption' for export compliance. This is used if there is 'ITSAppUsesNonExemptEncryption' is not set in the Info.plist',
                                     default_value: false,
                                     type: Boolean),
        FastlaneCore::ConfigItem.new(key: :distribute_external,
                                     is_string: false,
                                     env_name: 'PILOT_DISTRIBUTE_EXTERNAL',
                                     description: 'Should the build be distributed to external testers?',
                                     default_value: false),
        FastlaneCore::ConfigItem.new(key: :notify_external_testers,
                                    is_string: false,
                                    env_name: 'PILOT_NOTIFY_EXTERNAL_TESTERS',
                                    description: 'Should notify external testers?',
                                    default_value: true),
    
      protected
    
      def test_returns_success
    Warden.test_mode!
    
          # Sign in a user that already was authenticated. This helper is useful for logging
      # users in after sign up. All options given to sign_in is passed forward
      # to the set_user method in warden.
      # If you are using a custom warden strategy and the timeoutable module, you have to
      # set `env['devise.skip_timeout'] = true` in the request to use this method, like we do
      # in the sessions controller: https://github.com/plataformatec/devise/blob/master/app/controllers/devise/sessions_controller.rb#L7
      #
      # Examples:
      #
      #   sign_in :user, @user                      # sign_in(scope, resource)
      #   sign_in @user                             # sign_in(resource)
      #   sign_in @user, event: :authentication     # sign_in(resource, options)
      #   sign_in @user, store: false               # sign_in(resource, options)
      #
      def sign_in(resource_or_scope, *args)
        options  = args.extract_options!
        scope    = Devise::Mapping.find_scope!(resource_or_scope)
        resource = args.last || resource_or_scope
    
          # Initialize a new instance
      #
      # @param  [PodTarget, AggregateTarget] target @see target
      #
      def initialize(target)
        @target = target
        @headers = [
          Header.new(target.umbrella_header_path.basename, true),
        ]
      end
    
    if profile_filename = ENV['COCOAPODS_PROFILE']
  require 'ruby-prof'
  reporter =
    case (profile_extname = File.extname(profile_filename))
    when '.txt'
      RubyProf::FlatPrinterWithLineNumbers
    when '.html'
      RubyProf::GraphHtmlPrinter
    when '.callgrind'
      RubyProf::CallTreePrinter
    else
      raise 'Unknown profiler format indicated by extension: #{profile_extname}'
    end
  File.open(profile_filename, 'w') do |io|
    reporter.new(RubyProf.profile { Pod::Command.run(ARGV) }).print(io)
  end
else
  Pod::Command.run(ARGV)
end

    
            # @return [Bool] Bool indicating if this project is a pod target subproject.
        # Used by `generate_multiple_pod_projects` installation option.
        #
        attr_reader :pod_target_subproject
    
      # insert data
  fields.each do |field, values|
    updated = '  s.#{field} = ['
    updated << values.map { |v| '\n    %p' % v }.join(',')
    updated << '\n  ]'
    content.sub!(/  s\.#{field} = \[\n(    .*\n)*  \]/, updated)
  end
    
          def redirect(env)
        request = Request.new(env)
        warn env, 'attack prevented by #{self.class}'
        [302, {'Content-Type' => 'text/html', 'Location' => request.path}, []]
      end
    
          def escape_string(str)
        str = @escaper.escape_url(str)        if @url
        str = @escaper.escape_html(str)       if @html
        str = @escaper.escape_javascript(str) if @javascript
        str
      end
    end
  end
end

    
      describe '.token' do
    it 'returns a unique masked version of the authenticity token' do
      expect(Rack::Protection::AuthenticityToken.token(session)).not_to eq(masked_token)
    end
    
      it 'should allow changing report only' do
    # I have no clue what other modes are available
    mock_app do
      use Rack::Protection::ContentSecurityPolicy, :report_uri => '/my_amazing_csp_report_parser', :report_only => true
      run DummyApp
    end
    
        # Create the .txz package archive from the files in staging_path.
    File.open(output_path, 'wb') do |file|
      XZ::StreamWriter.new(file) do |xz|
        FPM::Util::TarWriter.new(xz) do |tar|
          # The manifests must come first for pkg.
          add_path(tar, '+COMPACT_MANIFEST',
                   File.join(staging_path, '+COMPACT_MANIFEST'))
          add_path(tar, '+MANIFEST',
                   File.join(staging_path, '+MANIFEST'))
    
    # Use an OS X pkg built with pkgbuild.
#
# Supports input and output. Requires pkgbuild and (for input) pkgutil, part of a
# standard OS X install in 10.7 and higher.
class FPM::Package::OSXpkg < FPM::Package
    
          # TODO(sissel): preinstall/postinstall
      # strip @prefix, since BASEDIR will set prefix via the pkginfo file
      IO.popen('pkgproto #{staging_path}/#{@prefix}=').each_line do |line|
        type, klass, path, mode, user, group = line.split