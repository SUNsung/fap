
        
                def initialize(object_name, method_name, template_object, collection, value_method, text_method, options, html_options)
          @collection   = collection
          @value_method = value_method
          @text_method  = text_method
          @html_options = html_options
    
                options = options.dup
            options[:field_name]           = @method_name
            options[:include_position]     = true
            options[:prefix]             ||= @object_name
            options[:index]                = @auto_index if @auto_index && !options.has_key?(:index)
    
    Benchmark.ips do |x|
  x.report('local-require') { local_require }
  x.report('global-require') { global_require }
  x.report('graceful-require') { graceful_require }
  x.compare!
end

    
    if pathutil_relative == native_relative
  Benchmark.ips do |x|
    x.report('pathutil') { pathutil_relative }
    x.report('native')   { native_relative }
    x.compare!
  end
else
  print 'PATHUTIL: '
  puts pathutil_relative
  print 'NATIVE:   '
  puts native_relative
end

    
    require 'fileutils'
require 'jekyll'
require 'time'
require 'safe_yaml/load'
    
              # This is too noisy even for --verbose, but uncomment if you need it for
          # a specific WebSockets issue.  Adding ?LR-verbose=true onto the URL will
          # enable logging on the client side.
          # em_opts[:debug] = true
    
        def process(args)
      arg_is_present? args, '--server', 'The --server command has been replaced by the \
                          'serve' subcommand.'
      arg_is_present? args, '--serve', 'The --serve command has been replaced by the \
                          'serve' subcommand.'
      arg_is_present? args, '--no-server', 'To build Jekyll without launching a server, \
                          use the 'build' subcommand.'
      arg_is_present? args, '--auto', 'The switch '--auto' has been replaced with \
                          '--watch'.'
      arg_is_present? args, '--no-auto', 'To disable auto-replication, simply leave off \
                          the '--watch' switch.'
      arg_is_present? args, '--pygments', 'The 'pygments'settings has been removed in \
                          favour of 'highlighter'.'
      arg_is_present? args, '--paginate', 'The 'paginate' setting can only be set in \
                          your config files.'
      arg_is_present? args, '--url', 'The 'url' setting can only be set in your \
                          config files.'
      no_subcommand(args)
    end
    
            UI.message('Adding git tag '#{tag}' ðŸŽ¯.')
        Actions.sh(cmd.join(' '))
      end
    
          context 'when specify framework' do
        let(:command) { 'archive' }
    
          context 'as array' do
        let(:path) { ['myfile.txt', 'yourfile.txt'] }
    
        # the value which is used during Swift code generation
    #   if the default_value reads from ENV or a file, or from local credentials, we need
    #   to provide a different default or it might be included in our autogenerated Swift
    #   as a built-in default for the fastlane gem. This is because when we generate the
    #   Swift API at deployment time, it fetches the default_value from the config_items
    attr_accessor :code_gen_default_value
    
      # make sure local implementation is also used in shelljoin
  def shelljoin(array)
    array.map { |arg| shellescape(arg) }.join(' ')
  end
  module_function :shelljoin
end
    
        describe 'shell escaping' do
      let(:keychain_name) { 'keychain with spaces.keychain' }
      let(:shell_escaped_name) { keychain_name.shellescape }
      let(:name_regex) { Regexp.new(Regexp.escape(shell_escaped_name)) }
    
              expect do
            FastlaneCore::Configuration.create(conflicting_options, values)
          end.to raise_error('You can't use option 'bar' along with 'foo'')
        end
      end
    
        if other.respond_to?(:to_str)
      return true if to_str == other.to_str
    end
    
      def path
    HOMEBREW_PINNED_KEGS/@f.name
  end
    
        it 'returns the value for a given string' do
      expect(subject.value('foo')).to eq ''
      expect(subject.value('bar')).to eq 'ab'
    end
    
      # Disable automatic flushing of the log to improve performance.
  # config.autoflush_log = false
    
          * Redistributions of source code must retain the above copyright
        notice, this list of conditions and the following disclaimer.
      * Redistributions in binary form must reproduce the above
        copyright notice, this list of conditions and the following
        disclaimer in the documentation and/or other materials provided
        with the distribution.
      * Neither the name of Google Inc. nor the names of its
        contributors may be used to endorse or promote products derived
        from this software without specific prior written permission.
    
          def sidebar
        if @sidebar.nil?
          if page = @page.sidebar
            @sidebar = page.text_data
          else
            @sidebar = false
          end
        end
        @sidebar
      end
    
      test 'remove page extentions' do
    view = Precious::Views::LatestChanges.new
    assert_equal 'page', view.remove_page_extentions('page.wiki')
    assert_equal 'page-wiki', view.remove_page_extentions('page-wiki.md')
    assert_equal 'file.any_extention', view.remove_page_extentions('file.any_extention')
  end
    
    # --gollum-path wins over ARGV[0]
gollum_path = ARGV[0] || Dir.pwd
    
    # Now, add our init-scripts, systemd services, and so on:
pleaserun = package.convert(FPM::Package::PleaseRun)
pleaserun.input ['/usr/bin/my-executable', '--foo-from', 'bar']
    
        if @name.include?('_')
      logger.warn('apk packages should not include underscores')
      @name = @name.gsub(/[_]/, '-')
    end
    
          if File.directory?(origin) && origin[-1,1] == '/'
        chdir = chdir == '.' ? origin : File.join(chdir, origin)
        source = '.'
      else
        origin_dir = File.dirname(origin)
        chdir = chdir == '.' ? origin_dir : File.join(chdir, origin_dir)
        source = File.basename(origin)
      end
    else
      source, destination = path, '/'
    end
    
        # Final edit for lint check and packaging
    edit_file(manifest_fn) if attributes[:edit?]