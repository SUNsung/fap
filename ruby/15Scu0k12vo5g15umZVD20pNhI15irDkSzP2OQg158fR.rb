
        
        RSpec::Matchers.define :have_path do |expected|
  match do |actual|
    await_condition { actual.current_path == expected }
  end
    
        t.before = lambda do
      if ENV['YARD_OPTS']
        require 'shellwords'
        t.options.concat(Shellwords.shellwords(ENV['YARD_OPTS']))
      end
    end
  end
  Rake::Task['yard'].prerequisites.insert(0, 'doc:sass')
  Rake::Task['yard'].instance_variable_set('@comment', nil)
    
          last.comment_tab_str ||= comment_tab_str
      last.text << '\n' << line
      true
    end
    
          opts.on('-s', '--stdin', :NONE,
              'Read input from standard input instead of an input file.',
              'This is the default if no input file is specified. Requires --from.') do
        @options[:input] = $stdin
      end
    
          # This is optional for backwards-compatibility with Sass 3.3, which didn't
      # enable sourcemaps by default and instead used '--sourcemap' to do so.
      opts.on(:OPTIONAL, '--sourcemap=TYPE',
          'How to link generated output to the source files.',
          '  auto (default): relative paths where possible, file URIs elsewhere',
          '  file: always absolute file URIs',
          '  inline: include the source text in the sourcemap',
          '  none: no sourcemaps') do |type|
        if type && !%w(auto file inline none).include?(type)
          $stderr.puts 'Unknown sourcemap type #{type}.\n\n'
          $stderr.puts opts
          exit
        elsif type.nil?
          Sass::Util.sass_warn <<MESSAGE.rstrip
DEPRECATION WARNING: Passing --sourcemap without a value is deprecated.
Sourcemaps are now generated by default, so this flag has no effect.
MESSAGE
        end
    
            found = possible_files(remove_root(name)).map do |f, s|
          path = if dir == '.' || Sass::Util.pathname(f).absolute?
                   f
                 else
                   '#{escape_glob_characters(dir)}/#{f}'
                 end
          Dir[path].map do |full_path|
            full_path.gsub!(REDUNDANT_DIRECTORY, File::SEPARATOR)
            [Sass::Util.cleanpath(full_path).to_s, s]
          end
        end.flatten(1)
        return if found.empty?
    
      def test_file_exists(path)
    exists?('f', path)
  end
    
            # rubocop:disable Style/MethodMissing
        def method_missing(key, value=nil)
          if value
            set(lvalue(key), value)
          else
            fetch(key)
          end
        end
        # rubocop:enable Style/MethodMissing
    
          def roles_for(names)
        options = extract_options(names)
        s = Filter.new(:role, names).filter(servers_by_key.values)
        s.select { |server| server.select?(options) }
      end
    
          def assert_value_or_block_not_both(value, block)
        return if value.nil? || block.nil?
        raise Capistrano::ValidationError,
              'Value and block both passed to Configuration#set'
      end
    
            if specs.size > 0
          specs
        else
          raise LogStash::PluginManager::PluginNotFoundError, 'Cannot find plugins matching: `#{plugin_pattern}`'
        end
      end.flatten
    end
    
      parameter '[PLUGIN] ...', 'Plugin name(s) to upgrade to latest version', :attribute_name => :plugins_arg
  option '--[no-]verify', :flag, 'verify plugin validity before installation', :default => true
  option '--local', :flag, 'force local-only plugin update. see bin/logstash-plugin package|unpack', :default => false
    
          it 'autocorrects closing brace on same line as last element' do
        new_source = autocorrect_source(<<-RUBY.strip_indent.chomp)
          #{prefix}#{open}#{a}, # a
          #{b}#{close} # b
          #{suffix}
        RUBY
    
          # Returns the else branch of the `case` statement, if any.
      #
      # @return [Node] the else branch node of the `case` statement
      # @return [nil] if the case statement does not have an else branch.
      def else_branch
        node_parts[-1]
      end
    
    module RuboCop
  module AST
    # A node extension for `for` nodes. This will be used in place of a plain
    # node when the builder constructs the AST, making its methods available
    # to all `for` nodes within RuboCop.
    class ForNode < Node
      # Returns the keyword of the `for` statement as a string.
      #
      # @return [String] the keyword of the `until` statement
      def keyword
        'for'
      end
    
    module RuboCop
  module AST
    # A node extension for `hash` nodes. This will be used in place of a plain
    # node when the builder constructs the AST, making its methods available
    # to all `hash` nodes within RuboCop.
    class HashNode < Node
      # Returns an array of all the key value pairs in the `hash` literal.
      #
      # @return [Array<PairNode>] an array of `pair` nodes
      def pairs
        each_pair.to_a
      end