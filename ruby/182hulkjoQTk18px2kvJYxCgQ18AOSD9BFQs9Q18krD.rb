
        
            it 'creates a scenario label with the given text' do
      expect(scenario_label(scenario, 'Other')).to eq(
        '<span class='label scenario' style='color:#AAAAAA;background-color:#000000'>Other</span>'
      )
    end
  end
    
        describe 'data' do
      it 'should be invalid with invalid data' do
        subject.data = invalid_data
        expect(subject).not_to be_valid
        expect(subject).to have(1).error_on(:base)
    
          it 'runs until stop is called' do
        mock.instance_of(Rufus::Scheduler).join
        Thread.new { while @agent_runner.instance_variable_get(:@running) != false do sleep 0.1; @agent_runner.stop end }
        @agent_runner.run
      end
    
        Thread.abort_on_exception = @taoe
    $stdout, $stderr = @oso, @ose
  end
    
        it 'html_safes the output unless :skip_safe is passed in' do
      expect(Utils.jsonify({:foo => 'bar'})).to be_html_safe
      expect(Utils.jsonify({:foo => 'bar'}, :skip_safe => false)).to be_html_safe
      expect(Utils.jsonify({:foo => 'bar'}, :skip_safe => true)).not_to be_html_safe
    end
  end
    
        it 'should revert extract and template options for an updated WebsiteAgent' do
      expect(agent.options).to include('extract' => new_extract,
                                       'template' => new_template)
      ConvertWebsiteAgentTemplateForMerge.new.down
      agent.reload
      expect(agent.options).to include('extract' => reverted_extract,
                                       'template' => reverted_template)
    end
  end
end

    
        # See {CapabilityHost#capability}
    def capability(*args)
      super
    rescue Errors::CapabilityNotFound => e
      raise Errors::GuestCapabilityNotFound,
        cap: e.extra_data[:cap],
        guest: name
    rescue Errors::CapabilityInvalid => e
      raise Errors::GuestCapabilityInvalid,
        cap: e.extra_data[:cap],
        guest: name
    end
    
        # Get a value by the given key.
    #
    # This will evaluate the block given to `register` and return the
    # resulting value.
    def get(key)
      return nil if !@items.key?(key)
      return @results_cache[key] if @results_cache.key?(key)
      @results_cache[key] = @items[key].call
    end
    alias :[] :get