
        
        def siteify_file(file, overrides_front_matter = {})
  abort 'You seem to have misplaced your #{file} file. I can haz?' unless File.exist?(file)
  title = begin
            File.read(file).match(%r!\A# (.*)$!)[1]
          rescue NoMethodError
            File.basename(file, '.*').downcase.capitalize
          end
  slug  = File.basename(file, '.markdown').downcase
  front_matter = {
    'title'     => title,
    'permalink' => '/docs/#{slug}/',
    'note'      => 'This file is autogenerated. Edit /#{file} instead.',
  }.merge(overrides_front_matter)
  contents = '#{front_matter.to_yaml}---\n\n#{content_for(file)}'
  File.write('#{docs_folder}/_docs/#{slug}.md', contents)
end
    
    FORWARD_SLASH = '/'.freeze
    
          attr_accessor :page, :layout, :content, :paginator
      attr_accessor :highlighter_prefix, :highlighter_suffix
    
    module Jekyll
  module Filters
    module GroupingFilters
      # Group an array of items by a property
      #
      # input - the inputted Enumerable
      # property - the property
      #
      # Returns an array of Hashes, each looking something like this:
      #  {'name'  => 'larry'
      #   'items' => [...] } # all the items where `property` == 'larry'
      def group_by(input, property)
        if groupable?(input)
          groups = input.group_by { |item| item_property(item, property).to_s }
          grouped_array(groups)
        else
          input
        end
      end
    
    module Fastlane
  # Handles receiving commands from the socket server, finding the Action to be invoked,
  # invoking it, and returning any return values
  class SocketServerActionCommandExecutor < CommandExecutor
    attr_accessor :runner
    attr_accessor :actions_requiring_special_handling
    
          it 'adds publish_docset param to command' do
        result = Fastlane::FastFile.new.parse('lane :test do
          appledoc(
            project_name: 'Project Name',
            project_company: 'Company',
            input: 'input/dir',
            publish_docset: true
          )
        end').runner.execute(:test)
    
          it 'handles the exclude_dirs parameter with no elements correctly' do
        result = Fastlane::FastFile.new.parse('lane :test do
          ensure_no_debug_code(text: 'pry', path: '.', exclude_dirs: [])
        end').runner.execute(:test)
        expect(result).to eq('grep -RE 'pry' '#{File.absolute_path('./')}'')
      end
    
          context 'with valid path to compile_commands.json' do
        context 'with no path to oclint' do
          let(:result) do
            Fastlane::FastFile.new.parse('lane :test do
              oclint( compile_commands: './fastlane/spec/fixtures/oclint/compile_commands.json' )
            end').runner.execute(:test)
          end
          let(:command) { 'cd #{File.expand_path('.').shellescape} && oclint -report-type=html -o=oclint_report.html' }
    
          it 'yields command output' do
        expect_command('ls', '-la', exitstatus: 1, output: 'Heeeelp! Something went wrong.')
        Fastlane::Actions.sh('ls', '-la') do |status, result|
          expect(status.exitstatus).to eq(1)
          expect(result).to eq('Heeeelp! Something went wrong.')
        end
      end
    
          # Reads a cache key.
      #
      # If the key exists and has a non-empty value its TTL is refreshed
      # automatically.
      #
      # raw_key - The cache key to read.
      # timeout - The new timeout of the key if the key is to be refreshed.
      def self.read(raw_key, timeout: TIMEOUT)
        key = cache_key_for(raw_key)
        value = Redis::Cache.with { |redis| redis.get(key) }
    
            def sidekiq_worker_class
          ImportIssueWorker
        end
    
        pod 'ObjCPod', path: 'ObjCPod'
    pod 'SwiftPod', path: 'SwiftPod'
    pod 'MixedPod', path: 'MixedPod'
    pod 'CustomModuleMapPod', path: 'CustomModuleMapPod'
    
    module LogStash
  module PluginManager
  end
end
    
      def target_file
    target_file = File.join(LogStash::Environment::LOGSTASH_HOME, 'plugins_package')
    '#{target_file}#{file_extension}'
  end
end

    
      # create list of plugins to update
  def plugins_to_update(previous_gem_specs_map)
    if update_all?
      previous_gem_specs_map.values.map{|spec| spec.name}
    else
      # If the plugins isn't available in the gemspec or in 
      # the gemfile defined with a local path, we assume the plugins is not
      # installed.
      not_installed = plugins_arg.select{|plugin| !previous_gem_specs_map.has_key?(plugin.downcase) && !gemfile.find(plugin) }
      signal_error('Plugin #{not_installed.join(', ')} is not installed so it cannot be updated, aborting') unless not_installed.empty?
      plugins_arg
    end
  end
    
      describe '#system?' do
    context 'when the pipeline is a system pipeline' do
      let(:settings) { mock_settings({ 'pipeline.system' => true })}
    
          it 'display a list of installed plugins' do
        result = logstash.run_command_in_path('bin/logstash-plugin list --installed')
        expect(result.stdout.split('\n').size).to be > 1
      end
    
          # Checks whether this `hash` uses a mix of hash rocket and colon
      # delimiters for its pairs.
      #
      # @return [Boolean] whether the `hash` uses mixed delimiters
      def mixed_delimiters?
        pairs.map(&:delimiter).uniq.size > 1
      end
    
    module RuboCop
  module Cop
    # Identifier of all cops containing a department and cop name.
    #
    # All cops are identified by their badge. For example, the badge
    # for `RuboCop::Cop::Layout::Tab` is `Layout/Tab`. Badges can be
    # parsed as either `Department/CopName` or just `CopName` to allow
    # for badge references in source files that omit the department
    # for RuboCop to infer.
    class Badge
      # Error raised when a badge parse fails.
      class InvalidBadge < Error
        MSG = 'Invalid badge %<badge>p. ' \
              'Expected `Department/CopName` or `CopName`.'.freeze