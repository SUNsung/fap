
        
                expect(FileStore::BaseStore.new.get_path_for_upload(upload))
          .to eq('original/2X/4/4170ac2a2782a1516fe9e13d7322ae482c1bd594.png')
      end
    end
    
        def handle_failure(mail_string, e)
      message_template = case e
                         when Email::Receiver::NoSenderDetectedError       then return nil
                         when Email::Receiver::FromReplyByAddressError     then return nil
                         when Email::Receiver::EmptyEmailError             then :email_reject_empty
                         when Email::Receiver::NoBodyDetectedError         then :email_reject_empty
                         when Email::Receiver::UserNotFoundError           then :email_reject_user_not_found
                         when Email::Receiver::ScreenedEmailError          then :email_reject_screened_email
                         when Email::Receiver::EmailNotAllowed             then :email_reject_not_allowed_email
                         when Email::Receiver::AutoGeneratedEmailError     then :email_reject_auto_generated
                         when Email::Receiver::InactiveUserError           then :email_reject_inactive_user
                         when Email::Receiver::SilencedUserError           then :email_reject_silenced_user
                         when Email::Receiver::BadDestinationAddress       then :email_reject_bad_destination_address
                         when Email::Receiver::StrangersNotAllowedError    then :email_reject_strangers_not_allowed
                         when Email::Receiver::InsufficientTrustLevelError then :email_reject_insufficient_trust_level
                         when Email::Receiver::ReplyUserNotMatchingError   then :email_reject_reply_user_not_matching
                         when Email::Receiver::TopicNotFoundError          then :email_reject_topic_not_found
                         when Email::Receiver::TopicClosedError            then :email_reject_topic_closed
                         when Email::Receiver::InvalidPost                 then :email_reject_invalid_post
                         when Email::Receiver::TooShortPost                then :email_reject_post_too_short
                         when Email::Receiver::UnsubscribeNotAllowed       then :email_reject_invalid_post
                         when ActiveRecord::Rollback                       then :email_reject_invalid_post
                         when Email::Receiver::InvalidPostAction           then :email_reject_invalid_post_action
                         when Discourse::InvalidAccess                     then :email_reject_invalid_access
                         when Email::Receiver::OldDestinationError         then :email_reject_old_destination
                         when Email::Receiver::ReplyNotAllowedError        then :email_reject_reply_not_allowed
                         else                                                   :email_reject_unrecognized_error
      end
    
        @user.update(last_posted_at: @post.created_at)
  end
    
      def remove_backups
    @objects.clear
  end
    
      def self.views_thresholds
    results = DB.query(<<~SQL)
      SELECT ranked.bucket * 5 as percentile, MIN(ranked.views) as views
      FROM (
        SELECT NTILE(20) OVER (ORDER BY t.views DESC) AS bucket, t.views
        FROM (
          SELECT views
            FROM topics
           WHERE deleted_at IS NULL
             AND archetype <> 'private_message'
             AND visible = TRUE
        ) t
      ) ranked
      WHERE bucket <= 9
      GROUP BY bucket
    SQL
    
          def self.output
        [
          ['LATEST_BUILD_NUMBER', 'The latest build number of either live or testflight version']
        ]
      end
    
    module Pilot
  class TesterManager < Manager
    def add_tester(options)
      start(options)
      app = find_app(apple_id: config[:apple_id], app_identifier: config[:app_identifier])
      UI.user_error!('You must provide either a Apple ID for the app (with the `:apple_id` option) or app identifier (with the `:app_identifier` option)') unless app
    
          def self.all(filter: {}, includes: nil, limit: nil, sort: nil)
        resps = Spaceship::ConnectAPI.get_bundle_ids(filter: filter, includes: includes).all_pages
        return resps.map(&:to_models).flatten
      end
    
          def self.all(filter: {}, includes: nil, limit: nil, sort: nil)
        resps = Spaceship::ConnectAPI.get_devices(filter: filter, includes: includes).all_pages
        return resps.map(&:to_models).flatten
      end
    end
  end
end

    
          def self.all(filter: {}, includes: nil, limit: nil, sort: nil)
        resps = Spaceship::ConnectAPI.get_profiles(filter: filter, includes: includes).all_pages
        return resps.map(&:to_models).flatten
      end
    end
  end
end

    
            keys.find do |key|
          key_tag_version = tag_without_or_later(key)
          begin
            MacOS::Version.from_symbol(key_tag_version) <= tag_version
          rescue ArgumentError
            false
          end
        end
      end
    end
  end
end

    
        it 'does not use older tags when requested not to', :needs_macos do
      allow(ARGV).to receive(:skip_or_later_bottles?).and_return(true)
      allow(OS::Mac).to receive(:prerelease?).and_return(true)
      subject[:mavericks] = 'foo'
      expect(subject.send(:find_matching_tag, :mavericks)).to eq(:mavericks)
      expect(subject.send(:find_matching_tag, :yosemite)).to be_nil
    end
    
        it 'hardcoded gcc compiler system' do
      expect_offense(<<~'RUBY')
        class Foo < Formula
          desc 'foo'
          url 'https://brew.sh/foo-1.0.tgz'
          def install
            system '/usr/bin/gcc', 'foo'
                    ^^^^^^^^^^^^ Use '#{ENV.cc}' instead of hard-coding 'gcc'
          end
        end
      RUBY
    end
    
        it 'When formula uses virtualenv and also `setuptools` resource' do
      expect_offense(<<~RUBY)
        class Foo < Formula
          url 'https://brew.sh/foo-1.0.tgz'
          homepage 'https://brew.sh'
    
      private
    
    module OS
  module Mac
    module_function
    
          def headers_installed?
        if !separate_header_package?
          installed?
        else
          headers_version == version
        end
      end
    
        context 'when URL ends with file' do
      it {
        expect(subject).to eq(
          HOMEBREW_CACHE/'downloads/3d1c0ae7da22be9d83fb1eb774df96b7c4da71d3cf07e1cb28555cf9a5e5af70--foo.tar.gz',
        )
      }
    end
    
        # Initiate a re-follow for each follower
    origin_account.followers.local.select(:id).find_in_batches do |follower_accounts|
      UnfollowFollowWorker.push_bulk(follower_accounts.map(&:id)) do |follower_account_id|
        [follower_account_id, origin_account.id, target_account.id]
      end
    end
  end
    
        old_account.update!(uri: 'https://example.org/alice', domain: 'example.org', protocol: :activitypub, inbox_url: 'https://example.org/inbox')
    new_account.update!(uri: 'https://example.com/alice', domain: 'example.com', protocol: :activitypub, inbox_url: 'https://example.com/inbox', also_known_as: [old_account.uri])
    
          it 'not calls errors.add' do
        expect(errors).not_to have_received(:add).with(:username, any_args)
      end
    end
    
        context 'if compliant?' do
      let(:compliant) { true }
    
    def codepoints_to_filename(codepoints)
  codepoints.downcase.gsub(/\A[0]+/, '').tr(' ', '-')
end
    
          context 'limit_reached?' do
        let(:limit_reached) { true }
    
      def perform
    eligible_users.reorder(nil).find_each do |user|
      next unless user.allows_digest_emails?
      DigestMailerWorker.perform_async(user.id)
    end
  end
    
          subject { described_class.new(json, sender, relayed_through_account: relay_account) }
    
    World(VagrantHelpers)

    
          super
    end
    
        def configure_backend
      backend.configure do |sshkit|
        configure_sshkit_output(sshkit)
        sshkit.output_verbosity = fetch(:log_level)
        sshkit.default_env      = fetch(:default_env)
        sshkit.backend          = fetch(:sshkit_backend, SSHKit::Backend::Netssh)
        sshkit.backend.configure do |backend|
          backend.pty                = fetch(:pty)
          backend.connection_timeout = fetch(:connection_timeout)
          backend.ssh_options        = (backend.ssh_options || {}).merge(fetch(:ssh_options, {}))
        end
      end
    end
    
          def select?(options)
        options.each do |k, v|
          callable = v.respond_to?(:call) ? v : ->(server) { server.fetch(v) }
          result = \
            case k
            when :filter, :select
              callable.call(self)
            when :exclude
              !callable.call(self)
            else
              fetch(k) == v
            end
          return false unless result
        end
    
            if callable_without_parameters?(value_to_evaluate)
          super(key, assert_valid_later(key, value_to_evaluate), &nil)
        else
          assert_valid_now(key, value_to_evaluate)
          super
        end
      end
    
          # Below article HTML variant
      it 'renders below article html variant' do
        html_variant = create(:html_variant, published: true, approved: true, group: 'article_show_below_article_cta')
        article.update_column(:body_markdown, rand(36**1000).to_s(36).to_s) # min length for article
        get article.path + '?variant_version=0'
        expect(response.body).to include html_variant.html
      end
    
      def permitted_attributes
    %i[title body_html body_markdown main_image published canonical_url
       description allow_small_edits allow_big_edits tag_list publish_under_org
       video video_code video_source_url video_thumbnail_url receive_notifications
       archived]
  end
    
      def update
    prevent_request_if_requested_twice
    @user = current_user
    @user.assign_attributes(user_params)
    @errors = []
    confirm_presence
    respond_to do |format|
      if @invalid_form
        render :edit
        return
      end
    
        def tmux_synchronize_panes
      '#{project.tmux} set-window-option -t #{tmux_window_target} synchronize-panes on'
    end
    
    describe Tmuxinator::Hooks::Project do
  let(:project) { FactoryBot.build(:project) }
    
      it { expect(subject.tmux_window_and_pane_target).to eql 'foo:0.1' }
end

    
      context 'no arguments' do
    it 'runs without error' do
      _, err = capture_io { cli.start }
      expect(err).to be_empty
    end
  end
    
          it 'returns an empty Array' do
        expect(window.panes).to be_empty
      end
    end