
        
            # Read all the files in <source>/<dir>/_drafts and create a new
    # Document object with each one.
    #
    # dir - The String relative path of the directory to read.
    #
    # Returns nothing.
    def read_drafts(dir)
      read_publishable(dir, '_drafts', Document::DATELESS_FILENAME_MATCHER)
    end
    
        # Initialize a new StaticFile.
    #
    # site - The Site.
    # base - The String path to the <source>.
    # dir  - The String path between <source> and the file.
    # name - The String filename of the file.
    # rubocop: disable ParameterLists
    def initialize(site, base, dir, name, collection = nil)
      @site = site
      @base = base
      @dir  = dir
      @name = name
      @collection = collection
      @relative_path = File.join(*[@dir, @name].compact)
      @extname = File.extname(@name)
      @data = @site.frontmatter_defaults.all(relative_path, type)
    end
    # rubocop: enable ParameterLists
    
              assert File.directory?(dest_dir)
          assert_exist dest_dir('contacts', 'index.html')
        end
    
          def collections
        @site_collections ||= @obj.collections.values.sort_by(&:label).map(&:to_liquid)
      end
    
            def setup
          @config['syntax_highlighter'] ||= highlighter
          @config['syntax_highlighter_opts'] ||= {}
          @config['syntax_highlighter_opts']['guess_lang'] = @config['guess_lang']
          @config['coderay'] ||= {} # XXX: Legacy.
          modernize_coderay_config
        end
    
    def siteify_file(file, overrides_front_matter = {})
  abort 'You seem to have misplaced your #{file} file. I can haz?' unless File.exist?(file)
  title = begin
            File.read(file).match(%r!\A# (.*)$!)[1]
          rescue NoMethodError
            File.basename(file, '.*').downcase.capitalize
          end
  slug  = File.basename(file, '.markdown').downcase
  front_matter = {
    'title'     => title,
    'permalink' => '/docs/#{slug}/',
    'note'      => 'This file is autogenerated. Edit /#{file} instead.',
  }.merge(overrides_front_matter)
  contents = '#{front_matter.to_yaml}---\n\n#{content_for(file)}'
  File.write('#{docs_folder}/_docs/#{slug}.md', contents)
end
    
    Benchmark.ips do |x|
  x.report('local-require') { local_require }
  x.report('global-require') { global_require }
  x.report('graceful-require') { graceful_require }
  x.compare!
end

    
          #
    
    module Jekyll
  module Commands
    class NewTheme < Jekyll::Command
      class << self
        def init_with_program(prog)
          prog.command(:'new-theme') do |c|
            c.syntax 'new-theme NAME'
            c.description 'Creates a new Jekyll theme scaffold'
            c.option 'code_of_conduct', \
                     '-c', '--code-of-conduct', \
                     'Include a Code of Conduct. (defaults to false)'
    
        return unless @status.preloadable_poll
    
      def inboxes
    # Deliver the status to all followers.
    # If the status is a reply to another local status, also forward it to that
    # status' authors' followers.
    @inboxes ||= if @status.reply? && @status.thread.account.local? && @status.distributable?
                   @account.followers.or(@status.thread.account.followers).inboxes
                 else
                   @account.followers.inboxes
                 end
  end
    
      def perform(account_id, options = {})
    @options = options.with_indifferent_access
    @account = Account.find(account_id)
    
          it 'processes payload with actor if valid signature exists' do
        payload['signature'] = { 'type' => 'RsaSignature2017' }
    
            # Specify additional content-types, e.g.:
        #   content_type :xls, 'application/vnd.ms-excel'
        def content_type(key, val)
          namespace_stackable(:content_types, key.to_sym => val)
        end
    
            presented_message
      end
    end
  end
end
