
        
            def tmux_main_command(command)
      if command
        _send_target(command.shellescape)
      else
        ''
      end
    end
    
        initialize_with { Tmuxinator::Project.new(file) }
  end
    
    shared_examples_for 'a project hook' do
  let(:project) { FactoryBot.build(:project) }
    
        msg = 'Actual pane does not match expected'
    msg << '\n  Expected #{@commands} but has #{actual.commands}' if @commands
    msg << '\n  Expected pane to have #{@expected_attrs}' if @expected_attrs
  end
    
        COMMANDS = {
      commands: 'Lists commands available in tmuxinator',
      completions: 'Used for shell completion',
      new: 'Create a new project file and open it in your editor',
      edit: 'Alias of new',
      open: 'Alias of new',
      start: %w{
        Start a tmux session using a project's name (with an optional [ALIAS]
        for project reuse) or a path to a project config file (via the -p flag)
      }.join(' '),
      stop: 'Stop a tmux session using a project's tmuxinator config',
      local: 'Start a tmux session using ./.tmuxinator.yml',
      debug: 'Output the shell commands that are generated by tmuxinator',
      copy: %w{
        Copy an existing project to a new project and
        open it in your editor
      }.join(' '),
      delete: 'Deletes given project',
      implode: 'Deletes all tmuxinator projects',
      version: 'Display installed tmuxinator version',
      doctor: 'Look for problems in your configuration',
      list: 'Lists all tmuxinator projects'
    }.freeze
    
          it 'returns false' do
        expect(described_class.shell?).to be_falsey
      end
    end
  end
end

    
      shared_context 'window command context' do
    let(:project) { double(:project) }
    let(:window) { described_class.new(yaml, 0, project) }
    let(:root?) { true }
    let(:root) { '/project/tmuxinator' }