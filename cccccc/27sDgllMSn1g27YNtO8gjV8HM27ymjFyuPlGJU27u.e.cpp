
        
        bool ParseAnyTypeUrl(const string& type_url, string* full_type_name) {
  return ParseAnyTypeUrl(type_url, NULL, full_type_name);
}
    
    // Parses a set of comma-delimited name/value pairs.
void ParseGeneratorParameter(const string& text,
                             std::vector<std::pair<string, string> >* output) {
  std::vector<string> parts = Split(text, ',', true);
    }
    
    std::string SourceGeneratorBase::class_access_level() {
  return (IsDescriptorProto(descriptor_) || this->options()->internal_access) ? 'internal' : 'public';
}
    
    // Get the name of an enum's Java class without package name prefix.
string ClassNameWithoutPackage(const EnumDescriptor* descriptor,
                               bool immutable) {
  // Doesn't append 'Mutable' for enum type's name.
  const Descriptor* message_descriptor = descriptor->containing_type();
  if (message_descriptor == NULL) {
    return descriptor->name();
  } else {
    return ClassNameWithoutPackage(message_descriptor, immutable) +
           '.' + descriptor->name();
  }
}
    
      if (HasDescriptorMethods(file_, options_.enforce_lite)) {
    // Generate descriptors.
    string classname = name_resolver_->GetDescriptorClassName(file_);
    string filename = package_dir + classname + '.java';
    file_list->push_back(filename);
    std::unique_ptr<io::ZeroCopyOutputStream> output(context->Open(filename));
    GeneratedCodeInfo annotations;
    io::AnnotationProtoCollector<GeneratedCodeInfo> annotation_collector(
        &annotations);
    std::unique_ptr<io::Printer> printer(
        new io::Printer(output.get(), '$',
                        options_.annotate_code ? &annotation_collector : NULL));
    string info_relative_path = classname + '.java.pb.meta';
    string info_full_path = filename + '.pb.meta';
    printer->Print(
        '// Generated by the protocol buffer compiler.  DO NOT EDIT!\n'
        '// source: $filename$\n'
        '\n',
        'filename', file_->name());
    if (!java_package.empty()) {
      printer->Print(
        'package $package$;\n'
        '\n',
        'package', java_package);
    }
    PrintGeneratedAnnotation(printer.get(), '$',
                             options_.annotate_code ? info_relative_path : '');
    printer->Print(
        'public final class $classname$ {\n'
        '  public static com.google.protobuf.Descriptors.FileDescriptor\n'
        '      descriptor;\n'
        '  static {\n',
        'classname', classname);
    printer->Annotate('classname', file_->name());
    printer->Indent();
    printer->Indent();
    GenerateDescriptors(printer.get());
    printer->Outdent();
    printer->Outdent();
    printer->Print(
      '  }\n'
      '}\n');
    }
    
    void OneofGenerator::GenerateClearFunctionDeclaration(io::Printer* printer) {
  printer->Print(
      variables_,
      '/**\n'
      ' * Clears whatever value was set for the oneof '$name$'.\n'
      ' **/\n'
      'void $owning_message_class$_Clear$capitalized_name$OneOfCase($owning_message_class$ *message);\n');
}
    
    TEST_P(DynamicMessageTest, Oneof) {
  // Check that oneof fields work properly.
  Arena arena;
  Message* message = oneof_prototype_->New(GetParam()? &arena : NULL);
    }
    
      // Parsing halted on a '.'.  Perhaps we're in a different locale?  Let's
  // try to replace the '.' with a locale-specific radix character and
  // try again.
  string localized = LocalizeRadix(text, temp_endptr);
  const char* localized_cstr = localized.c_str();
  char* localized_endptr;
  result = strtod(localized_cstr, &localized_endptr);
  if ((localized_endptr - localized_cstr) >
      (temp_endptr - text)) {
    // This attempt got further, so replacing the decimal must have helped.
    // Update original_endptr to point at the right location.
    if (original_endptr != NULL) {
      // size_diff is non-zero if the localized radix has multiple bytes.
      int size_diff = localized.size() - strlen(text);
      // const_cast is necessary to match the strtod() interface.
      *original_endptr = const_cast<char*>(
        text + (localized_endptr - localized_cstr - size_diff));
    }
  }
    
    Status KafkaTopicsConfigParserPlugin::update(const std::string& source,
                                             const ParserConfig& config) {
  auto topics = config.find(kKafkaTopicParserRootKey);
  if (topics != config.end()) {
    auto obj = data_.getObject();
    data_.copyFrom(topics->second.doc(), obj);
    data_.add(kKafkaTopicParserRootKey, obj);
  }
  return Status();
}
    
    ExpectedSuccess<DatabaseError> InMemoryDatabase::open() {
  debug_only::verifyTrue(!is_open_, 'database is already open');
  for (const auto& domain : kDomains) {
    storage_[domain] = std::make_unique<InMemoryStorage<DataType>>();
  }
  is_open_ = true;
  return Success();
}
    
      virtual void SetUp() {
    boost::uuids::uuid uuid = boost::uuids::random_generator()();
    auto random_name = boost::uuids::to_string(uuid);
    auto path = boost::filesystem::temp_directory_path().append(random_name);
    boost::filesystem::create_directory(path);
    path_ = path.string();
  }
    
    
    {} // namespace aria2

    
    #include 'DHTNode.h'
#include 'DHTBucket.h'
#include 'DHTBucketTree.h'
#include 'DHTTaskQueue.h'
#include 'DHTTaskFactory.h'
#include 'DHTTask.h'
#include 'util.h'
#include 'LogFactory.h'
#include 'Logger.h'
#include 'fmt.h'
    
      ~DHTRoutingTableDeserializer();
    
    
    {} // namespace aria2

    
    
    {} // namespace aria2

    
    void DHTTaskFactoryImpl::setRoutingTable(DHTRoutingTable* routingTable)
{
  routingTable_ = routingTable;
}
    
    #include <memory>
    
      virtual void executeTask() CXX11_OVERRIDE;
    
    DHTTokenUpdateCommand::~DHTTokenUpdateCommand() = default;
    
    void DNSCache::put(const std::string& hostname, const std::string& ipaddr,
                   uint16_t port)
{
  auto target = std::make_shared<CacheEntry>(hostname, port);
  auto i = entries_.lower_bound(target);
  if (i != entries_.end() && *(*i) == *target) {
    (*i)->add(ipaddr);
  }
  else {
    target->add(ipaddr);
    entries_.insert(i, target);
  }
}
    
        template <typename OutputIterator>
    void getAllGoodAddrs(OutputIterator out) const
    {
      for (auto& elem : addrEntries_) {
        if (elem.good_) {
          *out++ = elem.addr_;
        }
      }
    }
    
      int64_t num_record_drop_hidden = 0;
  int64_t num_record_drop_obsolete = 0;
  int64_t num_record_drop_range_del = 0;
  int64_t num_range_del_drop_obsolete = 0;
  // Deletions obsoleted before bottom level due to file gap optimization.
  int64_t num_optimized_del_drop_obsolete = 0;
  uint64_t total_filter_time = 0;
    
    std::unique_ptr<WriteControllerToken> WriteController::GetDelayToken(
    uint64_t write_rate) {
  total_delayed_++;
  // Reset counters.
  last_refill_time_ = 0;
  bytes_left_ = 0;
  set_delayed_write_rate(write_rate);
  return std::unique_ptr<WriteControllerToken>(new DelayWriteToken(this));
}
    
      uint64_t max_delayed_write_rate() const { return max_delayed_write_rate_; }
    
    
    {  // Means Close() will properly take care of truncate
  // and it does not need any additional information
  virtual Status Truncate(uint64_t /*size*/) override { return Status::OK(); }
  virtual Status Close() override;
  virtual Status Append(const Slice& data) override;
  virtual Status Flush() override;
  virtual Status Sync() override;
  virtual Status Fsync() override;
  virtual uint64_t GetFileSize() override;
  virtual Status InvalidateCache(size_t offset, size_t length) override;
#ifdef ROCKSDB_FALLOCATE_PRESENT
  virtual Status Allocate(uint64_t offset, uint64_t len) override;
#endif
};
    
      DB* db = nullptr;
  DestroyDB(kDBPath, options);
  Status s = DB::Open(options, kDBPath, &db);
  assert(s.ok());
  assert(db);
    
      // In this example, we set the snapshot multiple times.  This is probably
  // only necessary if you have very strict isolation requirements to
  // implement.
    
    #include 'rocksdb/db.h'
    
    class DB;
    
    
    {}  // namespace rocksdb
#endif  // !ROCKSDB_LITE

    
    #include 'modules/drivers/canbus/can_comm/can_sender.h'
    
    #include 'modules/drivers/canbus/can_comm/message_manager.h'
    
    #include 'modules/drivers/radar/conti_radar/protocol/object_quality_info_60c.h'
#include 'modules/drivers/radar/conti_radar/protocol/const_vars.h'
    
    Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an 'AS IS' BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
=========================================================================*/
    
    namespace apollo {
namespace planning {
    }
    }
    
    Spline1dSeg::Spline1dSeg(const uint32_t order) {
  SetSplineFunc(PolynomialXd(order));
}
    
      const LaneGraph &lane_graph =
      ObstacleClusters::GetLaneGraph(start_s, length, lane);
  EXPECT_EQ(1, lane_graph.lane_sequence_size());
  EXPECT_EQ(3, lane_graph.lane_sequence(0).lane_segment_size());
  EXPECT_EQ('l9', lane_graph.lane_sequence(0).lane_segment(0).lane_id());
  EXPECT_EQ('l18', lane_graph.lane_sequence(0).lane_segment(1).lane_id());
  EXPECT_EQ('l21', lane_graph.lane_sequence(0).lane_segment(2).lane_id());
    
      FunctionRef<int(int, char const*)> variant5 = of;
  EXPECT_EQ(100 + 5 * 19, variant5(19, 'foo'));
  FunctionRef<int(int, char const*)> const cvariant5 = of;
  EXPECT_EQ(100 + 5 * 19, cvariant5(19, 'foo'));
    
    
    {
    {    if (provider == expectedProvider && probe == expectedProbe) {
      CHECK_EQ(expectedSemaphore, semaphoreAddr);
      return true;
    }
  }
  return false;
}
    
    #include <folly/Range.h>
    
    
    {} // namespace uri_detail
    
          void operator()() {
        f_();
      }
    
    #endif // FOLLY_HAVE_LIBZ
