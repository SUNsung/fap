
        
        // This class stores everything that StreamExecutor needs to launch a DNN
// convolution. It is generated by IrEmitter.
//
// This is thread-compatible.
class ConvolutionThunk : public Thunk {
 public:
  // Constructs a thunk for launching a DNN convolution.  When run, it will
  // write a tuple (result, scratch_memory) into `tuple_result_buffer`.
  //
  // operand_slices should be in the same order as cudnn_call->operands().
  ConvolutionThunk(const HloCustomCallInstruction* cudnn_call,
                   std::vector<BufferAllocation::Slice> operand_slices,
                   BufferAllocation::Slice result_slice,
                   BufferAllocation::Slice scratch_slice,
                   BufferAllocation::Slice tuple_result_slice);
    }
    
    // ForThunk executes 'loop_limit' invocations of 'body_thunk_sequence'.
class ForThunk : public Thunk {
 public:
  ForThunk(const int64 loop_limit,
           std::unique_ptr<ThunkSequence> body_thunk_sequence,
           const HloInstruction* hlo);
  ForThunk(const ForThunk&) = delete;
  ForThunk& operator=(const ForThunk&) = delete;
    }
    
    #include 'tensorflow/compiler/xla/service/gpu/outfeed_thunk.h'
#include 'tensorflow/compiler/xla/literal.h'
#include 'tensorflow/compiler/xla/service/gpu/hlo_execution_profiler.h'
#include 'tensorflow/compiler/xla/service/gpu/outfeed_manager.h'
#include 'tensorflow/compiler/xla/util.h'
#include 'tensorflow/core/platform/stream_executor_no_cuda.h'
    
    #include 'tensorflow/compiler/xla/service/gpu/buffer_allocations.h'
#include 'tensorflow/compiler/xla/service/gpu/hlo_execution_profiler.h'
#include 'tensorflow/compiler/xla/service/gpu/thunk.h'
#include 'tensorflow/compiler/xla/service/hlo_instruction.h'
#include 'tensorflow/core/platform/stream_executor_no_cuda.h'
    
    
    {}  // namespace xla
    
    
    {    xla::XlaBuilder* builder = context->builder();
    auto buffer = xla::Broadcast(XlaHelpers::Zero(builder, dtype),
                                 buffer_shape.dim_sizes());
    auto indices = context->Input(0);
    auto updates = context->Input(1);
    auto result =
        XlaScatter(buffer, updates, indices,
                   /*indices_are_vectors=*/true, /*combiner=*/Combine, builder);
    OP_REQUIRES_OK(context, result.status());
    context->SetOutput(0, result.ValueOrDie());
  }
    
      // Replace old apply instruction by a new apply instruction that invokes
  // the witness thunk.
  SILBuilderWithScope Builder(AI.getInstruction());
  SILLocation Loc = AI.getLoc();
  auto *FRI = Builder.createFunctionRefFor(Loc, F);
    
        // Collect witness method implementations.
    for (SILWitnessTable &WT : Module->getWitnessTableList()) {
      auto Conf = WT.getConformance();
      for (const SILWitnessTable::Entry &entry : WT.getEntries()) {
        if (entry.getKind() != SILWitnessTable::Method)
          continue;
    }
    }
    
    // Crash due to a weak retain count overflow.
// FIXME: can't pass the object's address from InlineRefCounts without hacks
void swift::swift_abortWeakRetainOverflow() {
  swift::fatalError(FatalErrorFlags::ReportBacktrace,
                    'Fatal error: Object's weak reference was retained too many times');
}
    
    #ifndef SWIFT_SIL_DEBUGSCOPE_H
#define SWIFT_SIL_DEBUGSCOPE_H
    
      bool isEnum() const {
    return (Kind == FieldDescriptorKind::Enum ||
            Kind == FieldDescriptorKind::MultiPayloadEnum);
  }
    
    /// Get the unsubstituted capture types for a closure context.
ClosureContextInfo
TypeRefBuilder::getClosureContextInfo(const CaptureDescriptor &CD,
                                      uint64_t TypeRefOffset) {
  ClosureContextInfo Info;
    }
    
    #endif // SWIFT_ABI_KEYPATH_H

    
    struct BlobData {
  BlobData() : blob(nullptr), choices(nullptr) {}
  BlobData(int index, Tesseract* tess, const WERD_RES& word)
    : blob(word.chopped_word->blobs[index]),
      tesseract(tess),
      choices(&(*word.ratings)(index, index)) {}
    }
    
    
    {  bool rword_indicates_list_item;
  bool rword_likely_starts_idea;
  bool rword_likely_ends_idea;
};
    
    
    {  // Stores all the source points in the order they were given and their
  // halfwidths, if any.
  GenericVector<PointWidth> pts_;
  // Stores the computed perpendicular distances of (some of) the pts_ from a
  // given vector (assuming it goes through the origin, making it a line).
  // Since the distances may be a subset of the input points, and get
  // re-ordered by the nth_item function, the original point is stored
  // along side the distance.
  GenericVector<DistPointPair> distances_;  // Distances of points.
  // The squared length of the vector used to compute distances_.
  double square_length_;
};
    
    class QRSequenceGenerator {
 public:
  // Object is initialized with the size of the output range.
  explicit QRSequenceGenerator(int N) : N_(N), next_num_(0) {
    num_bits_ = static_cast<int>(ceil(log(static_cast<double>(N)) / log(2.0)));
  }
    }
    
    #include 'unichar.h'
    
    
    {    float posX = 0;
    auto lastChild = Children->GetAt(Children->Size - 1);
    float lastChildWidth = 0;
    if (Children->Size > 2 && ShouldPrioritizeLastItem())
    {
        lastChildWidth = lastChild->DesiredSize.Width;
    }
    for (auto item : Children)
    {
        auto widthAvailable = finalSize.Width - posX;
        if (item != lastChild)
        {
            widthAvailable -= lastChildWidth;
        }
        float itemWidth = item->DesiredSize.Width;
        if (widthAvailable > 0 && itemWidth <= widthAvailable)
        {
            // stack the items horizontally (left to right)
            item->Arrange(Rect(posX, 0, itemWidth, finalSize.Height));
            AutomationProperties::SetAccessibilityView(item, ::AccessibilityView::Content);
            posX += item->RenderSize.Width;
        }
        else
        {
            // Not display the item
            item->Arrange(Rect(0, 0, 0, 0));
            AutomationProperties::SetAccessibilityView(item, ::AccessibilityView::Raw);
        }
    }
    return finalSize;
}

    
        Rational& Rational::operator^=(Rational const& rhs)
    {
        PRAT lhsRat = this->ToPRAT();
        PRAT rhsRat = rhs.ToPRAT();
        try
        {
            xorrat(&lhsRat, rhsRat, RATIONAL_BASE, RATIONAL_PRECISION);
            destroyrat(rhsRat);
        }
        catch (uint32_t error)
        {
            destroyrat(lhsRat);
            destroyrat(rhsRat);
            throw(error);
        }
    }
    
            UINT m_initCallCount;
        UINT m_getCategoriesCallCount;
        UINT m_setCurrentCategoryCallCount;
        UINT m_setCurUnitTypesCallCount;
        UINT m_switchActiveCallCount;
        UINT m_sendCommandCallCount;
        UINT m_setVMCallbackCallCount;
    
    // Update the commands corresponding to the passed string Number
std::shared_ptr<CalculatorVector<int>> CHistoryCollector::GetOperandCommandsFromString(wstring_view numStr)
{
    std::shared_ptr<CalculatorVector<int>> commands = std::make_shared<CalculatorVector<int>>();
    // Check for negate
    bool fNegative = (numStr[0] == L'-');
    }
    
            private:
            // ICollectionView
            // Not implemented methods
            virtual WF::IAsyncOperation<
                Windows::UI::Xaml::Data::LoadMoreItemsResult> ^ LoadMoreItemsAsync(unsigned int) = Windows::UI::Xaml::Data::ICollectionView::LoadMoreItemsAsync
            {
                throw ref new Platform::NotImplementedException();
            }
            virtual bool MoveCurrentToFirst() = Windows::UI::Xaml::Data::ICollectionView::MoveCurrentToFirst
            {
                throw ref new Platform::NotImplementedException();
            }
            virtual bool MoveCurrentToLast() = Windows::UI::Xaml::Data::ICollectionView::MoveCurrentToLast
            {
                throw ref new Platform::NotImplementedException();
            }
            virtual bool MoveCurrentToNext() = Windows::UI::Xaml::Data::ICollectionView::MoveCurrentToNext
            {
                throw ref new Platform::NotImplementedException();
            }
            virtual bool MoveCurrentToPrevious() = Windows::UI::Xaml::Data::ICollectionView::MoveCurrentToPrevious
            {
                throw ref new Platform::NotImplementedException();
            }
            property Windows::Foundation::Collections::IObservableVector<Platform::Object ^> ^ CollectionGroups {
                virtual Windows::Foundation::Collections::IObservableVector<
                    Platform::Object ^> ^ get() = Windows::UI::Xaml::Data::ICollectionView::CollectionGroups::get
                {
                    return ref new Platform::Collections::Vector<Platform::Object ^>();
                }
            } property bool HasMoreItems
            {
                virtual bool get() = Windows::UI::Xaml::Data::ICollectionView::HasMoreItems::get
                {
                    return false;
                }
            }
    
    INarratorAnnouncementHost ^ LiveRegionHost::MakeHost()
{
    return ref new LiveRegionHost();
}
    
    /* TessCallback */
#define GLU_TESS_BEGIN                     100100
#define GLU_BEGIN                          100100
#define GLU_TESS_VERTEX                    100101
#define GLU_VERTEX                         100101
#define GLU_TESS_END                       100102
#define GLU_END                            100102
#define GLU_TESS_ERROR                     100103
#define GLU_TESS_EDGE_FLAG                 100104
#define GLU_EDGE_FLAG                      100104
#define GLU_TESS_COMBINE                   100105
#define GLU_TESS_BEGIN_DATA                100106
#define GLU_TESS_VERTEX_DATA               100107
#define GLU_TESS_END_DATA                  100108
#define GLU_TESS_ERROR_DATA                100109
#define GLU_TESS_EDGE_FLAG_DATA            100110
#define GLU_TESS_COMBINE_DATA              100111
    
    //------------------------------------------------------------------------
// PSOutputDev
//------------------------------------------------------------------------
    
      // read a token
  i = 0;
  buf[i++] = c;
  if (c == '(') {
    backslash = gFalse;
    while ((c = lookChar()) != EOF) {
      consumeChar();
      if (i < size) {
	buf[i++] = c;
      }
      if (c == '\\') {
	backslash = gTrue;
      } else if (!backslash && c == ')') {
	break;
      } else {
	backslash = gFalse;
      }
    }
  } else if (c == '<') {
    while ((c = lookChar()) != EOF) {
      consumeChar();
      if (i < size && specialChars[c] != 1) {
	buf[i++] = c;
      }
      if (c == '>') {
	break;
      }
    }
  } else if (c != '[' && c != ']') {
    while ((c = lookChar()) != EOF && !specialChars[c]) {
      consumeChar();
      if (i < size) {
	buf[i++] = c;
      }
    }
  }
  // Zero terminate token string
  buf[i] = '\0';
  // Return length of token
  *length = i;
    
      count = p - buffer;
  if (buffer[0] >= 'a' && buffer[0] <= 'z')
    return 26 * (count - 1) + buffer[0] - 'a' + 1;
  if (buffer[0] >= 'A' && buffer[0] <= 'Z')
    return 26 * (count - 1) + buffer[0] - 'A' + 1;
    
      // Get alignment
  PageTransitionAlignment getAlignment() { return alignment; }
    
      colorSpace = colorMap->getColorSpace();
  if (colorSpace->getMode() == csIndexed) {
    colorSpace = ((GfxIndexedColorSpace *)colorSpace)->getBase();
  }
  if (colorSpace->getMode() != csDeviceGray &&
      colorSpace->getMode() != csCalGray) {
    gray = gFalse;
  }
  mono = gFalse;
  if (state->getBlendMode() != gfxBlendNormal) {
    transparency = gTrue;
  }
  gdi = gFalse;
    
    Sound *Sound::parseSound(Object *obj)
{
  // let's try to see if this Object is a Sound, according to the PDF specs
  // (section 9.2)
  Stream *str = NULL;
  // the Object must be a Stream
  if (obj->isStream()) {
    str = obj->getStream();
  } else {
    return NULL;
  }
  // the Stream must have a Dict
  Dict *dict = str->getDict();
  if (dict == NULL)
    return NULL;
  Object tmp;
  // the Dict must have the 'R' key of type num
  dict->lookup('R', &tmp);
  if (tmp.isNum()) {
    return new Sound(obj);
  } else {
    return NULL;
  }
}
    
    TEST(pipe, base)
{
    swPipe p;
    int ret;
    char data[256];
    }
    
        for (const auto &arg : args)
    {
        coro_test_create(arg.first, arg.second, &complete_num);
    }
    
    namespace swoole_test
{
static int my_onPacket(swServer *serv, swEventData *req);
static int my_onReceive(swServer *serv, swEventData *req);
static void my_onStart(swServer *serv);
static void my_onShutdown(swServer *serv);
static void my_onConnect(swServer *serv, swDataHead *info);
static void my_onClose(swServer *serv, swDataHead *info);
static void my_onWorkerStart(swServer *serv, int worker_id);
static void my_onWorkerStop(swServer *serv, int worker_id);
    }
    
        bzero(&un1,sizeof(struct sockaddr_un));
    bzero(&un2,sizeof(struct sockaddr_un));
    
    static int thread_onTask(swThreadPool *pool, void *task, int task_len)
{
    sw_atomic_long_t *n = (sw_atomic_long_t *) task;
    sw_atomic_fetch_add(n, 1);
    if (*n == N - 1)
    {
        write(_pipe, (void*) n, sizeof(long));
    }
    return SW_OK;
}
    
        SwooleG.use_signalfd = 1;
    
    
    {        cache_list.emplace_front(key, cache_node_t{expire_time, val});
        cache_map[key] = cache_list.begin();
    }