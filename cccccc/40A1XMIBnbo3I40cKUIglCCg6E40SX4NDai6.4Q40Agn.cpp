
        
        
    {}  // namespace mate
    
    namespace base {
class FilePath;
}
    
      int signal;
  size_t bytes_read = 0;
  ssize_t ret;
  do {
    ret = HANDLE_EINTR(
        read(shutdown_fd_,
             reinterpret_cast<char*>(&signal) + bytes_read,
             sizeof(signal) - bytes_read));
    if (ret < 0) {
      NOTREACHED() << 'Unexpected error: ' << strerror(errno);
      ShutdownFDReadError();
      break;
    } else if (ret == 0) {
      NOTREACHED() << 'Unexpected closure of shutdown pipe.';
      ShutdownFDClosedError();
      break;
    }
    bytes_read += ret;
  } while (bytes_read < sizeof(signal));
  VLOG(1) << 'Handling shutdown for signal ' << signal << '.';
  base::Closure task =
      base::Bind(&Browser::Quit, base::Unretained(Browser::Get()));
    
    #include 'atom/browser/browser.h'
#include 'atom/common/native_mate_converters/net_converter.h'
#include 'base/values.h'
#include 'content/public/browser/browser_thread.h'
#include 'content/public/browser/render_frame_host.h'
#include 'content/public/browser/resource_dispatcher_host.h'
#include 'content/public/browser/resource_request_info.h'
#include 'content/public/browser/web_contents.h'
#include 'net/base/auth.h'
#include 'net/url_request/url_request.h'
    
    #ifndef ATOM_BROWSER_NET_ASAR_ASAR_PROTOCOL_HANDLER_H_
#define ATOM_BROWSER_NET_ASAR_ASAR_PROTOCOL_HANDLER_H_
    
    namespace atom {
    }
    
      {1,0,32,  &_residue_44_low_un,
   &_huff_book__44u0__long,&_huff_book__44u0__long,
   &_resbook_44u_0,&_resbook_44u_0}
};
static const vorbis_residue_template _res_44u_1[]={
  {1,0,16,  &_residue_44_low_un,
   &_huff_book__44u1__short,&_huff_book__44u1__short,
   &_resbook_44u_1,&_resbook_44u_1},
    
    /*
 * This is basically a special Intel version. Point is that Intel
 * doesn't have many registers, but offers a reach choice of addressing
 * modes. So we spare some registers by directly traversing BF_KEY
 * structure and hiring the most decorated addressing mode. The code
 * generated by EGCS is *perfectly* competitive with assembler
 * implementation!
 */
#  define BF_ENC(LL,R,KEY,Pi) (\
        LL^=KEY[Pi], \
        t=  KEY[BF_ROUNDS+2 +   0 + ((R>>24)&0xFF)], \
        t+= KEY[BF_ROUNDS+2 + 256 + ((R>>16)&0xFF)], \
        t^= KEY[BF_ROUNDS+2 + 512 + ((R>>8 )&0xFF)], \
        t+= KEY[BF_ROUNDS+2 + 768 + ((R    )&0xFF)], \
        LL^=t \
        )
    
        uint64_t c = duration_cast<nanoseconds>(system_clock::now()
                                            .time_since_epoch()).count();
    
    template <class I1, class I2>
struct ValueCompatible : std::is_base_of<I1, I2> {};
    
    #include <algorithm>
#include <array>
#include <atomic>
#include <cassert>
#include <functional>
#include <limits>
#include <mutex>
#include <string>
#include <type_traits>
#include <unordered_map>
#include <vector>
    
    namespace detail {
    }
    
    /***
 *  The qfind_first_byte_of_* functions are declared here, before Range.h, so
 *  they cannot take StringPiece values. But they're there to operate on
 *  StringPiece values. Dependency cycles: fun.
 *
 *  StringPieceLite is here to break that dependency cycle.
 */
class StringPieceLite {
 public:
  StringPieceLite(const char* b, const char* e) : b_(b), e_(e) {}
  template <typename Range>
  /* implicit */ StringPieceLite(const Range& r)
      : StringPieceLite(r.data(), r.data() + r.size()) {}
  const char* data() const {
    return b_;
  }
  const char* begin() const {
    return b_;
  }
  const char* end() const {
    return e_;
  }
  size_t size() const {
    return size_t(e_ - b_);
  }
  bool empty() const {
    return size() == 0;
  }
  const char& operator[](size_t i) const {
    DCHECK_GT(size(), i);
    return b_[i];
  }
  template <typename Range>
  explicit operator Range() const {
    return Range(begin(), end());
  }
    }
    
    #include <folly/Likely.h>
    
    TEST(TearableTest, BasicOperations) {
  Tearable<Data> tearable;
  Data src(0);
  Data dst(1);
  for (char c = 0; c < 10; ++c) {
    src.setValue(c);
    tearable.store(src);
    tearable.load(dst);
    dst.checkValue(c);
  }
}