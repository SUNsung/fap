
        
        template <typename DescriptorType>
static void WriteDocCommentBody(
    io::Printer* printer, const DescriptorType* descriptor) {
    SourceLocation location;
    if (descriptor->GetSourceLocation(&location)) {
        WriteDocCommentBodyImpl(printer, location);
    }
}
    
    #include <google/protobuf/compiler/csharp/csharp_doc_comment.h>
#include <google/protobuf/compiler/csharp/csharp_enum.h>
#include <google/protobuf/compiler/csharp/csharp_helpers.h>
#include <google/protobuf/compiler/csharp/csharp_options.h>
    
    namespace google {
namespace protobuf {
namespace compiler {
namespace csharp {
namespace {
    }
    }
    }
    }
    }
    
    void ReflectionClassGenerator::WriteIntroduction(io::Printer* printer) {
  printer->Print(
    '// <auto-generated>\n'
    '//     Generated by the protocol buffer compiler.  DO NOT EDIT!\n'
    '//     source: $file_name$\n'
    '// </auto-generated>\n'
    '#pragma warning disable 1591, 0612, 3021\n'
    '#region Designer generated code\n'
    '\n'
    'using pb = global::Google.Protobuf;\n'
    'using pbc = global::Google.Protobuf.Collections;\n'
    'using pbr = global::Google.Protobuf.Reflection;\n'
    'using scg = global::System.Collections.Generic;\n',
    'file_name', file_->name());
    }
    
    TEST(JavaDocCommentTest, Escaping) {
  EXPECT_EQ('foo /&#42; bar *&#47; baz', EscapeJavadoc('foo /* bar */ baz'));
  EXPECT_EQ('foo /&#42;&#47; baz', EscapeJavadoc('foo /*/ baz'));
  EXPECT_EQ('{&#64;foo}', EscapeJavadoc('{@foo}'));
  EXPECT_EQ('&lt;i&gt;&amp;&lt;/i&gt;', EscapeJavadoc('<i>&</i>'));
  EXPECT_EQ('foo&#92;u1234bar', EscapeJavadoc('foo\\u1234bar'));
  EXPECT_EQ('&#64;deprecated', EscapeJavadoc('@deprecated'));
}
    
    ServiceGenerator* ImmutableGeneratorFactory::NewServiceGenerator(
    const ServiceDescriptor* descriptor) const {
  return new ImmutableServiceGenerator(descriptor, context_);
}
    
    string ClassNameResolver::GetClassName(const EnumDescriptor* descriptor,
                                       bool immutable) {
  return GetClassFullName(ClassNameWithoutPackage(descriptor, immutable),
                          descriptor->file(), immutable,
                          MultipleJavaFiles(descriptor->file(), immutable));
}
    
      string file_data;
  file_proto.SerializeToString(&file_data);
    
    namespace google {
namespace protobuf {
class FieldDescriptor;  // descriptor.h
namespace io {
class Printer;  // printer.h
}
}
    }
    
      // open device
  // guss net is the device minor number, if one card is 0,1
  // if more than one card, when install driver u can specify the minior id
  // int32_t ret = canOpen(net, pCtx->mode, txbufsize, rxbufsize, 0, 0,
  // &dev_handler_);
  uint32_t mode = 0;
  // mode |= NTCAN_MODE_NO_RTR;
  if (port_ > MAX_CAN_PORT || port_ < 0) {
    AERROR << 'can port number [' << port_ << '] is out of the range [0,'
           << MAX_CAN_PORT << ']';
    return ErrorCode::CAN_CLIENT_ERROR_BASE;
  }
  int32_t ret = canOpen(port_, mode, NTCAN_MAX_TX_QUEUESIZE,
                        NTCAN_MAX_RX_QUEUESIZE, 5, 5, &dev_handler_);
  if (ret != NTCAN_SUCCESS) {
    AERROR << 'open device error code [' << ret << ']: ' << GetErrorString(ret);
    return ErrorCode::CAN_CLIENT_ERROR_BASE;
  }
    
      /**
   * @brief Send messages
   * @param frames The messages to send.
   * @param frame_num The amount of messages to send.
   * @return The status of the sending action which is defined by
   *         apollo::common::ErrorCode.
   */
  apollo::common::ErrorCode Send(const std::vector<CanFrame> &frames,
                                 int32_t *const frame_num) override;
    
    DECLARE_string(adapter_config_filename);