
        
          // An AST section consists of one or more AST modules, optionally with
  // headers. Iterate over all AST modules.
  while (!buf.empty()) {
    auto info = serialization::validateSerializedAST(buf);
    }
    
    #ifndef DIRECTIONAL_PREPOSITION
#  define DIRECTIONAL_PREPOSITION(Word) PREPOSITION(Word)
#endif
    
    DummyTaskQueue::~DummyTaskQueue() = default;
    
    namespace clang {
class Sema;
class NamedDecl;
class TypeDecl;
class FunctionDecl;
}
    
    #include 'swift/Demangling/Demangle.h'
#include 'swift/Demangling/Demangler.h'
#include <cstdio>
    
    bool GodotCollisionDispatcher::needsCollision(const btCollisionObject *body0, const btCollisionObject *body1) {
	if (body0->getUserIndex() == CASTED_TYPE_AREA || body1->getUserIndex() == CASTED_TYPE_AREA) {
		// Avoide area narrow phase
		return false;
	}
	return btCollisionDispatcher::needsCollision(body0, body1);
}
    
    class RigidBodyBullet;
class btTypedConstraint;
    
    	real_t getSoftnessDirLin() const;
	real_t getRestitutionDirLin() const;
	real_t getDampingDirLin() const;
	real_t getSoftnessDirAng() const;
	real_t getRestitutionDirAng() const;
	real_t getDampingDirAng() const;
	real_t getSoftnessLimLin() const;
	real_t getRestitutionLimLin() const;
	real_t getDampingLimLin() const;
	real_t getSoftnessLimAng() const;
	real_t getRestitutionLimAng() const;
	real_t getDampingLimAng() const;
	real_t getSoftnessOrthoLin() const;
	real_t getRestitutionOrthoLin() const;
	real_t getDampingOrthoLin() const;
	real_t getSoftnessOrthoAng() const;
	real_t getRestitutionOrthoAng() const;
	real_t getDampingOrthoAng() const;
	void setSoftnessDirLin(real_t softnessDirLin);
	void setRestitutionDirLin(real_t restitutionDirLin);
	void setDampingDirLin(real_t dampingDirLin);
	void setSoftnessDirAng(real_t softnessDirAng);
	void setRestitutionDirAng(real_t restitutionDirAng);
	void setDampingDirAng(real_t dampingDirAng);
	void setSoftnessLimLin(real_t softnessLimLin);
	void setRestitutionLimLin(real_t restitutionLimLin);
	void setDampingLimLin(real_t dampingLimLin);
	void setSoftnessLimAng(real_t softnessLimAng);
	void setRestitutionLimAng(real_t restitutionLimAng);
	void setDampingLimAng(real_t dampingLimAng);
	void setSoftnessOrthoLin(real_t softnessOrthoLin);
	void setRestitutionOrthoLin(real_t restitutionOrthoLin);
	void setDampingOrthoLin(real_t dampingOrthoLin);
	void setSoftnessOrthoAng(real_t softnessOrthoAng);
	void setRestitutionOrthoAng(real_t restitutionOrthoAng);
	void setDampingOrthoAng(real_t dampingOrthoAng);
	void setPoweredLinMotor(bool onOff);
	bool getPoweredLinMotor();
	void setTargetLinMotorVelocity(real_t targetLinMotorVelocity);
	real_t getTargetLinMotorVelocity();
	void setMaxLinMotorForce(real_t maxLinMotorForce);
	real_t getMaxLinMotorForce();
	void setPoweredAngMotor(bool onOff);
	bool getPoweredAngMotor();
	void setTargetAngMotorVelocity(real_t targetAngMotorVelocity);
	real_t getTargetAngMotorVelocity();
	void setMaxAngMotorForce(real_t maxAngMotorForce);
	real_t getMaxAngMotorForce();
	real_t getLinearPos();
    
    MemoryPool::Alloc *MemoryPool::allocs = NULL;
MemoryPool::Alloc *MemoryPool::free_list = NULL;
uint32_t MemoryPool::alloc_count = 0;
uint32_t MemoryPool::allocs_used = 0;
Mutex *MemoryPool::alloc_mutex = NULL;
    
    Shell::~Shell() {
}
    
    #endif  // MXNET_GRAPH_ATTR_TYPES_H_

    
    /**
 * \brief The interface to convert mxnet's tensor to caffe's blob
 * \brief called in caffe_operator_inl.h
 */
template<typename Device, typename Dtype>
void TBlob2CaffeBlob(caffeMemoryTypes memType,
                     typename std::vector< ::caffe::Blob<Dtype>*>::iterator blob,
                     typename std::vector<TBlob>::const_iterator tblob,
                     int n = 1) {
  for (int i = 0; i < n; ++i, ++blob, ++tblob) {
    (*blob)->Reshape(TShape2Vector((*tblob).shape_));
    SetDataGradToBlob<Device, Dtype>(memType, blob, tblob);
  }
}
    
    MXNET_REGISTER_OP_PROPERTY(CaffeLoss, CaffeLossProp)
.describe('Caffe loss layer')
.add_arguments(CaffeLossParam::__FIELDS__());
    
    namespace mxnet {
namespace engine {
/*!
 * \brief ThreadedEngine using global thread pool across all devices.
 * The policy of this Engine:
 *  - Execute Async operation immediately if pushed from Pusher.
 *  - Use a common thread pool for normal operations on all devices.
 *  - Use special thread pool for copy operations.
 */
class ThreadedEnginePooled : public ThreadedEngine {
 public:
  ThreadedEnginePooled() {
    this->Start();
  }
    }
    }
    }
    
    Example::
    
      /**
   * \fn  virtual void Predictor::PredictLeaf(DMatrix* dmat,
   * std::vector<bst_float>* out_preds, const gbm::GBTreeModel& model, unsigned
   * ntree_limit = 0) = 0;
   *
   * \brief predict the leaf index of each tree, the output will be nsample *
   * ntree vector this is only valid in gbtree predictor.
   *
   * \param [in,out]  dmat        The input feature matrix.
   * \param [in,out]  out_preds   The output preds.
   * \param           model       Model to make predictions from.
   * \param           ntree_limit (Optional) The ntree limit.
   */
    
      inline void ParseStr(std::string *tok) {
    while ((ch_buf_ = this->GetChar()) != EOF) {
      switch (ch_buf_) {
        case '\\': *tok += this->GetChar(); break;
        case '\'': return;
        case '\r':
        case '\n': LOG(FATAL)<< 'ConfigReader: unterminated string';
        default: *tok += ch_buf_;
      }
    }
    LOG(FATAL) << 'ConfigReader: unterminated string';
  }
  inline void ParseStrML(std::string *tok) {
    while ((ch_buf_ = this->GetChar()) != EOF) {
      switch (ch_buf_) {
        case '\\': *tok += this->GetChar(); break;
        case '\'': return;
        default: *tok += ch_buf_;
      }
    }
    LOG(FATAL) << 'unterminated string';
  }
  // return newline
  inline bool GetNextToken(std::string *tok) {
    tok->clear();
    bool new_line = false;
    while (ch_buf_ != EOF) {
      switch (ch_buf_) {
        case '#' : SkipLine(); new_line = true; break;
        case '\'':
          if (tok->length() == 0) {
            ParseStr(tok); ch_buf_ = this->GetChar(); return new_line;
          } else {
            LOG(FATAL) << 'ConfigReader: token followed directly by string';
          }
        case '\'':
          if (tok->length() == 0) {
            ParseStrML(tok); ch_buf_ = this->GetChar(); return new_line;
          } else {
            LOG(FATAL) << 'ConfigReader: token followed directly by string';
          }
        case '=':
          if (tok->length() == 0) {
            ch_buf_ = this->GetChar();
            *tok = '=';
          }
          return new_line;
        case '\r':
        case '\n':
          if (tok->length() == 0) new_line = true;
        case '\t':
        case ' ' :
          ch_buf_ = this->GetChar();
          if (tok->length() != 0) return new_line;
          break;
        default:
          *tok += ch_buf_;
          ch_buf_ = this->GetChar();
          break;
      }
    }
    if (tok->length() == 0) {
      return true;
    } else {
      return false;
    }
  }
};
/*!
 * \brief an iterator use stream base, allows use all types of istream
 */
class ConfigStreamReader: public ConfigReaderBase {
 public:
  /*!
   * \brief constructor
   * \param fin istream input stream
   */
  explicit ConfigStreamReader(std::istream &fin) : fin_(fin) {}
    
    
    {    inline size_t Size() const {
      return end - begin;
    }
  };
  /* \brief specifies how to split a rowset into two */
  struct Split {
    std::vector<size_t> left;
    std::vector<size_t> right;
  };
    
    
    {
    {void SparsePageWriter::Alloc(std::shared_ptr<SparsePage>* out_page) {
  CHECK(*out_page == nullptr);
  if (num_free_buffer_ != 0) {
    out_page->reset(new SparsePage());
    --num_free_buffer_;
  } else {
    CHECK(qrecycle_.Pop(out_page));
  }
}
}  // namespace data
}  // namespace xgboost
    
            static float f = 0.0f;
        ImGui::Text('Hello, world!');
        ImGui::SliderFloat('float', &f, 0.0f, 1.0f);
        ImGui::Text('Application average %.3f ms/frame (%.1f FPS)', 1000.0f / io.Framerate, io.Framerate);
        ImGui::ShowDemoWindow(NULL);
    
        // Setup render state
    const float blend_factor[4] = { 0.f, 0.f, 0.f, 0.f };
    ctx->OMSetBlendState(g_pBlendState, blend_factor, 0xffffffff);
    ctx->OMSetDepthStencilState(g_pDepthStencilState, 0);
    ctx->RSSetState(g_pRasterizerState);
    
        ImGui_ImplVulkanH_FrameData* fd = &wd->Frames[wd->FrameIndex];
    {
		err = vkWaitForFences(g_Device, 1, &fd->Fence, VK_TRUE, UINT64_MAX);	// wait indefinitely instead of periodically checking
        check_vk_result(err);
    }
    
                    // Average normals
                ImVec2 dm = (temp_normals[i1] + temp_normals[i2]) * 0.5f;
                float dmr2 = dm.x*dm.x + dm.y*dm.y;
                if (dmr2 > 0.000001f)
                {
                    float scale = 1.0f / dmr2;
                    if (scale > 100.0f) scale = 100.0f;
                    dm *= scale;
                }
                dm *= AA_SIZE;
                temp_points[i2*2+0] = points[i2] + dm;
                temp_points[i2*2+1] = points[i2] - dm;