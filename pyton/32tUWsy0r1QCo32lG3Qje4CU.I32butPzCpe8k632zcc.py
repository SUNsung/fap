
        
        
def test_custom_tag():
    class Foo(object):
        def __init__(self, data):
            self.data = data
    
        :param root_path: path to which files are read relative from.  When the
                      config object is created by the application, this is
                      the application's :attr:`~flask.Flask.root_path`.
    :param defaults: an optional dictionary of default values
    '''
    
    
def test_explicit_instance_paths(modules_tmpdir):
    with pytest.raises(ValueError) as excinfo:
        flask.Flask(__name__, instance_path='instance')
    assert 'must be absolute' in str(excinfo.value)
    
    
def test_logger_debug(app):
    app.debug = True
    assert app.logger.level == logging.DEBUG
    assert app.logger.handlers == [default_handler]
    
        with app.test_request_context('/'):
        assert flask.url_for('index', _external=True) == \
               'http://localhost.localdomain:5000/'
    
        def record_push(sender, **kwargs):
        recorded.append('push')
    
        if WSAStringToAddressA(
            ip_string,
            address_family,
            None,
            ctypes.byref(addr),
            ctypes.byref(addr_size)
    ) != 0:
        raise socket.error(ctypes.FormatError())
    
    These recognizers are baseclasses for the code which is generated by ANTLR3.
    
                    if self.eot[s] >= 0:
                    #print 'EOT to %d' % self.eot[s]
                    
                    s = self.eot[s]
                    input.consume()
                    continue
    
        return (major, minor, patch, beta)