
        
            if WSAAddressToStringA(
            ctypes.byref(addr),
            addr_size,
            None,
            ip_string,
            ctypes.byref(ip_string_size)
    ) != 0:
        raise socket.error(ctypes.FormatError())
    
            if high_prior_connecting_num + low_prior_connecting_num < config.https_max_connect_thread:
            if len(high_prior_lock):
                atom_lock = high_prior_lock.pop()
                atom_lock.release()
                return
    
        return version_string
    
    This module contains all support classes, which are needed to use recognizers
generated by ANTLR3.
    
            Because the user is not required to use a token with an index stored
        in it, we must provide a means for two token objects themselves to
        indicate the start/end location.  Most often this will just delegate
        to the other toString(int,int).  This is also parallel with
        the TreeNodeStream.toString(Object,Object).
	'''
    
        @declared_attr
    def slices(self):
        return relationship(
            'Slice',
            primaryjoin=lambda: and_(
                foreign(Slice.datasource_id) == self.id,
                foreign(Slice.datasource_type) == self.type,
            ),
        )
    
        @classmethod
    def register_sources(cls, datasource_config):
        for module_name, class_names in datasource_config.items():
            class_names = [str(s) for s in class_names]
            module_obj = __import__(module_name, fromlist=class_names)
            for class_name in class_names:
                source_class = getattr(module_obj, class_name)
                cls.sources[source_class.type] = source_class
    
    from flask import flash, Markup, redirect
from flask_appbuilder import CompactCRUDMixin, expose
from flask_appbuilder.models.sqla.interface import SQLAInterface
from flask_babel import gettext as __
from flask_babel import lazy_gettext as _
    
    
appbuilder.add_view_no_menu(SqlMetricInlineView)
    
        @classmethod
    def is_date(cls, dtype):
        if dtype.name:
            return dtype.name.startswith('datetime')
    
         Metrics and columns and datasource will be overrided if exists.
     This function can be used to import/export dashboards between multiple
     superset instances. Audit metadata isn't copies over.
    '''
    make_transient(i_datasource)
    logging.info('Started import of the datasource: {}'.format(
        i_datasource.to_json()))
    
    
def cast_form_data(form_data):
    '''Translates old to new form_data'''
    d = {}
    fields = frontend_config.get('controls', {})
    for k, v in form_data.items():
        field_config = fields.get(k, {})
        ft = field_config.get('type')
        if ft == 'CheckboxControl':
            # bug in some urls with dups on bools
            if isinstance(v, list):
                v = 'y' in v
            else:
                v = True if v in ('true', 'y') or v is True else False
        elif v and ft == 'TextControl' and field_config.get('isInt'):
            v = int(v) if v != '' else None
        elif v and ft == 'TextControl' and field_config.get('isFloat'):
            v = float(v) if v != '' else None
        elif v and ft == 'SelectControl':
            if field_config.get('multi'):
                if type(form_data).__name__ == 'ImmutableMultiDict':
                    v = form_data.getlist(k)
                elif not isinstance(v, list):
                    v = [v]
        if d.get('slice_id'):
            d['slice_id'] = int(d['slice_id'])
    
    from __future__ import unicode_literals
from __future__ import print_function
from __future__ import division
from __future__ import absolute_import
# No imports from `future` because when this is loaded, sys.path hasn't been set
# up yet!
    
            result_item = result_queue.get(block=True)
        if result_item is not None:
            work_item = pending_work_items[result_item.work_id]
            del pending_work_items[result_item.work_id]
    
    # A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []
    
    
  @staticmethod
  def CreateFromOptions( user_options ):
    all_filters = dict( user_options.get( 'filter_diagnostics', {} ) )
    compiled_by_type = {}
    for type_spec, filter_value in iteritems( dict( all_filters ) ):
      filetypes = [ type_spec ]
      if type_spec.find( ',' ) != -1:
        filetypes = type_spec.split( ',' )
      for filetype in filetypes:
        compiled_by_type[ filetype ] = _CompileFilters( filter_value )
    
    
class TestData(unittest.TestCase):
    
    
### OUTPUT ###
# <NumObj: -1>
# <NumObj: 0>
# <NumObj: 1>
# <NumObj: 2>
# -- committed
# <NumObj: 3>
# <NumObj: 4>
# <NumObj: 5>
# -- rolled back
# <NumObj: 2>
# -- now doing stuff ...
# -> doing stuff failed!
# Traceback (most recent call last):
# File 'memento.py', line 97, in <module>
#     num_obj.do_stuff()
#   File 'memento.py', line 52, in transaction
#     raise e
#   File 'memento.py', line 49, in transaction
#     return self.method(obj, *args, **kwargs)
#   File 'memento.py', line 70, in do_stuff
#     self.increment()     # <- will fail and rollback
#   File 'memento.py', line 65, in increment
#     self.value += 1
# TypeError: Can't convert 'int' object to str implicitly
# <NumObj: 2>
