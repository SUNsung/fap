
        
            def __init__(self, get_response=None):
        if not apps.is_installed('django.contrib.sites'):
            raise ImproperlyConfigured(
                'You cannot use RedirectFallbackMiddleware when '
                'django.contrib.sites is not installed.'
            )
        super().__init__(get_response)
    
        @classmethod
    def get_session_store_class(cls):
        raise NotImplementedError
    
            if 'quality' in stream:
            print('      quality:       %s' % stream['quality'])
    
        vid = r1('data-vid='(\d+)'', html)
    up = r1('data-name='([^']+)'', html)
    p_title = r1('active'>([^<]+)', html)
    title = '%s (%s)' % (title, up)
    if p_title: title = '%s - %s' % (title, p_title)
    acfun_download_by_vid(vid, title,
                          output_dir=output_dir,
                          merge=merge,
                          info_only=info_only,
                          **kwargs)
    
    __all__ = ['baomihua_download', 'baomihua_download_by_id']
    
    from ..common import *
    
        print_info(site_info, title, type, size)
    if not info_only:
        download_urls(urls, title, ext, size, output_dir, merge=False)
    
    #----------------------------------------------------------------------
def fc2video_download_by_upid(upid, output_dir = '.', merge = True, info_only = False, **kwargs):
    ''''''
    fake_headers = {
        'DNT': '1',
        'Accept-Encoding': 'gzip, deflate, sdch',
        'Accept-Language': 'en-CA,en;q=0.8,en-US;q=0.6,zh-CN;q=0.4,zh;q=0.2',
        'User-Agent': 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_11_1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/47.0.2526.58 Safari/537.36',
        'Accept': '*/*',
        'X-Requested-With': 'ShockwaveFlash/19.0.0.245',
        'Connection': 'keep-alive',
    }
    api_base = 'http://video.fc2.com/ginfo.php?upid={upid}&mimi={mimi}'.format(upid = upid, mimi = makeMimi(upid))
    html = get_content(api_base, headers=fake_headers)
    
    def fetch_photo_url_list(url, size):
    for pattern in url_patterns:
        # FIXME: fix multiple matching since the match group is dropped
        if match1(url, pattern[0]):
            return fetch_photo_url_list_impl(url, size, *pattern[1:])
    raise NotImplementedError('Flickr extractor is not supported for %s.' % url)
    
      new_candidates = []
  for candidate in candidates:
    if isinstance( candidate, dict ):
      new_candidate = candidate.copy()
    
    
  def Start( self ):
    request_data = BuildRequestData()
    if self._extra_data:
      request_data.update( self._extra_data )
    self._response = self.PostDataToHandler( request_data,
                                             'debug_info',
                                             display_message = False )
    
      f = _CreateFilterForTypes( opts, [ 'java', 'xml' ] )
    
    
class FakeFuture( object ):
  '''A fake version of a future response object, just about suitable for
  mocking a server response as generated by PostDataToHandlerAsync.
  Not usually used directly. See MockAsyncServerResponse* methods'''
  def __init__( self, done, response = None, exception = None ):
    self._done = done
    
    
@patch( 'ycm.vimsupport.CurrentFiletypes', return_value = [ 'ycmtest' ] )
def OnCompleteDone_NoActionNoError_test( *args ):
  request = CompletionRequest( None )
  request.Done = MagicMock( return_value = True )
  request._OnCompleteDone_Csharp = MagicMock()
  request._OnCompleteDone_FixIt = MagicMock()
  request.OnCompleteDone()
  request._OnCompleteDone_Csharp.assert_not_called()
  request._OnCompleteDone_FixIt.assert_not_called()
    
      def run( self ):
    if not self.future.set_running_or_notify_cancel():
      return