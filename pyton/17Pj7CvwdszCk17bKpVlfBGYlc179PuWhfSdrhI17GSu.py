
        
          with gfile.FastGFile(FLAGS.spec_file, 'w') as f:
    f.write(str(master_spec).encode('utf-8'))
    
    tf_gen_op_wrapper_py(
    name = 'dragnn_ops',
    deps = [':dragnn_ops_op_lib'],
)
    
        master_spec = spec_pb2.MasterSpec()
    text_format.Parse('''
        component {
          name: 'test'
          transition_system {
            registered_name: 'shift-only'
          }
          resource {
            name: 'label-map'
            part {
              file_pattern: '%s'
              file_format: 'text'
            }
          }
          network_unit {
            registered_name: 'ExportFixedFeaturesNetwork'
          }
          backend {
            registered_name: 'SyntaxNetComponent'
          }
          fixed_feature {
            name: 'focus1' embedding_dim: -1 size: 1 fml: 'input.focus'
            predicate_map: 'none'
          }
          fixed_feature {
            name: 'focus2' embedding_dim: -1 size: 1 fml: 'input(1).focus'
            predicate_map: 'none'
          }
          fixed_feature {
            name: 'focus3' embedding_dim: -1 size: 1 fml: 'input(2).focus'
            predicate_map: 'none'
          }
        }
        ''' % path, master_spec)
    
        Returns:
      List of tensors generated by the underlying network implementation.
    '''
    with tf.variable_scope(self.name, reuse=True):
      fixed_embeddings = []
      for channel_id, feature_spec in enumerate(self.spec.fixed_feature):
        fixed_embedding = network_units.fixed_feature_lookup(
            self, state, channel_id, stride, during_training)
        if feature_spec.is_constant:
          fixed_embedding.tensor = tf.stop_gradient(fixed_embedding.tensor)
        fixed_embeddings.append(fixed_embedding)
    
      def testRootPotentialsFromTokens(self):
    with self.test_session():
      root = tf.constant([1, 2], tf.float32)
      tokens = tf.constant([[[4, 5, 6],
                             [5, 6, 7],
                             [6, 7, 8]],
                            [[6, 7, 8],
                             [5, 6, 7],
                             [4, 5, 6]]], tf.float32)  # pyformat: disable
      weights_arc = tf.constant([[2, 3, 5],
                                 [7, 11, 13]],
                                tf.float32)  # pyformat: disable
      weights_source = tf.constant([11, 10], tf.float32)
    
    else:
    text_type = unicode
    string_types = (str, unicode)
    integer_types = (int, long)
    
        If there is no handler for the logger's effective level, add a
    :class:`~logging.StreamHandler` for
    :func:`~flask.logging.wsgi_errors_stream` with a basic format.
    '''
    logger = logging.getLogger('flask.app')
    
        This module provides class-based views inspired by the ones in Django.
    
    import pytest
from werkzeug.exceptions import NotFound
    
        def test_sys_path_adjustment_removes_argv0_dir(self):
        clean_path = self._get_starting_path()
        expected_path = [self.abs_curdir] + clean_path
        leading_argv0dir = [self.argv0dir] + clean_path
        self.assertEqual(self._get_revised_path(leading_argv0dir), expected_path)
        trailing_argv0dir = clean_path + [self.argv0dir]
        self.assertEqual(self._get_revised_path(trailing_argv0dir), expected_path)
    
    def start():
    function_1()
    function_2()
    function_3(1, 2)
    function_4(test=42)
    function_5(*(1, 2), **{'test': 42})
    
        def setUp(self):
        self._threading_key = support.threading_setup()
        self.alive = {}
        self.stop = 0
        self.threads = []
    
        all -       Enable all special resources.
    
    
# When tests are run from the Python build directory, it is best practice
# to keep the test files in a subfolder.  This eases the cleanup of leftover
# files using the 'make distclean' command.
if sysconfig.is_python_build():
    TEMPDIR = sysconfig.get_config_var('abs_builddir')
    if TEMPDIR is None:
        # bpo-30284: On Windows, only srcdir is available. Using abs_builddir
        # mostly matters on UNIX when building Python out of the source tree,
        # especially when the source tree is read only.
        TEMPDIR = sysconfig.get_config_var('srcdir')
    TEMPDIR = os.path.join(TEMPDIR, 'build')
else:
    TEMPDIR = tempfile.gettempdir()
TEMPDIR = os.path.abspath(TEMPDIR)
    
        # Save current values for dash_R_cleanup() to restore.
    fs = warnings.filters[:]
    ps = copyreg.dispatch_table.copy()
    pic = sys.path_importer_cache.copy()
    try:
        import zipimport
    except ImportError:
        zdc = None # Run unmodified on platforms without zipimport support
    else:
        zdc = zipimport._zip_directory_cache.copy()
    abcs = {}
    for abc in [getattr(collections.abc, a) for a in collections.abc.__all__]:
        if not isabstract(abc):
            continue
        for obj in abc.__subclasses__() + [abc]:
            abcs[obj] = _get_dump(obj)[0]