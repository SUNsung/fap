
        
        usage:
    
    # Scrapy version
import pkgutil
__version__ = pkgutil.get_data(__package__, 'VERSION').decode('ascii').strip()
version_info = tuple(int(v) if v.isdigit() else v
                     for v in __version__.split('.'))
del pkgutil
    
            if self.downloader.active:
            # downloader has pending requests
            return False
    
    
class CookiesMiddleware(object):
    '''This middleware enables working with sites that need cookies'''
    
    from scrapy.utils.python import without_none_values
    
    from scrapy import signals
    
    See documentation in docs/topics/downloader-middleware.rst
'''
    
        def _decode(self, body, encoding):
        if encoding == b'gzip' or encoding == b'x-gzip':
            body = gunzip(body)
    
    
def new_pteredor(probe_nat=True):
    if os.path.isfile(log_file):
        try:
            os.remove(log_file)
        except Exception as e:
            xlog.warn('remove %s fail:%r', log_file, e)
    
    # Predefined token types
EOR_TOKEN_TYPE = 1
    
        Any state that has a semantic predicate edge is special; those states
    are generated with if-then-else structures in a specialStateTransition()
    which is generated by cyclicDFA template.
    
    '''
    
    def __init__(
        self,
        recognizer, decisionNumber,
        eot, eof, min, max, accept, special, transition
        ):
        ## Which recognizer encloses this DFA?  Needed to check backtracking
        self.recognizer = recognizer
    
    import cv2
from ._base import Output, logger
    
        def check_transparency_format(self):
        ''' Make sure that the output format is correct if draw_transparent is selected '''
        transparent = self.config['draw_transparent']
        if not transparent or (transparent and self.config['format'] in ('png', 'tif')):
            return
        logger.warning('Draw Transparent selected, but the requested format does not support '
                       'transparency. Changing output format to 'png'')
        self.config['format'] = 'png'
    
            kernel_fourier_shape = correct_fft(np.zeros(kernel_shape)).shape
        init = []
        for _ in range(filters_size):
            basis = self._create_basis(
                stack_size, np.prod(kernel_fourier_shape), dtype)
            basis = basis.reshape((stack_size,) + kernel_fourier_shape)
    
        def progress_set_mode(self, mode):
        ''' Set the progress bar mode '''
        self.pbar.config(mode=mode)
        if mode == 'indeterminate':
            self.pbar.config(maximum=100)
            self.pbar.start()
        else:
            self.pbar.stop()
            self.pbar.config(maximum=100)
    
        def start(self) -> None:
        '''Starts the timer.'''
        # Looking up the IOLoop here allows to first instantiate the
        # PeriodicCallback in another thread, then start it using
        # IOLoop.add_callback().
        self.io_loop = IOLoop.current()
        self._running = True
        self._next_timeout = self.io_loop.time()
        self._schedule_next()
    
          wait_iterator = gen.WaitIterator(awaitable1, awaitable2)
      while not wait_iterator.done():
          try:
              result = yield wait_iterator.next()
          except Exception as e:
              print('Error {} from {}'.format(e, wait_iterator.current_future))
          else:
              print('Result {} received from {} at {}'.format(
                  result, wait_iterator.current_future,
                  wait_iterator.current_index))
    
    
def main():
    parse_command_line()
    t = Timer(e1)
    results = t.timeit(options.num) / options.num
    print('engine: %0.3f ms per iteration' % (results * 1000))
    t = Timer(c1)
    results = t.timeit(options.num) / options.num
    print('coroutine: %0.3f ms per iteration' % (results * 1000))
    
        for i in range(1, num_tests + 1):
        logging.info('running test case %d', i)
        url = options.url + '/runCase?case=%d&agent=%s' % (i, options.name)
        test_ws = yield websocket_connect(url, None, compression_options={})
        while True:
            message = yield test_ws.read_message()
            if message is None:
                break
            test_ws.write_message(message, binary=isinstance(message, bytes))
    
        def test_multi_release(self):
        lock = locks.Lock()
        self.assertRaises(RuntimeError, lock.release)
        lock.acquire()
        lock.release()
        self.assertRaises(RuntimeError, lock.release)
    
        async def oauth2_request(
        self,
        url: str,
        access_token: Optional[str] = None,
        post_args: Optional[Dict[str, Any]] = None,
        **args: Any
    ) -> Any:
        '''Fetches the given URL auth an OAuth2 access token.