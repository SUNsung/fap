
        
                self.selenium.find_element_by_xpath('//input[@value='Save']').click()
        self.wait_page_loaded()
    
        def test_parameter_substitution(self):
        'Redirection URLs can be parameterized'
        response = RedirectView.as_view(url='/bar/%(object_id)d/')(self.rf.get('/foo/42/'), object_id=42)
        self.assertEqual(response.status_code, 302)
        self.assertEqual(response.url, '/bar/42/')
    
            if lookup.band_rhs is not None and rhs_is_raster:
            if not self.func:
                raise ValueError('Band indices are not allowed for this operator, it works on bbox only.')
            template_params['rhs'] = '%s, %s' % (template_params['rhs'], lookup.band_rhs)
    
            for version in versions:
            with self.subTest(version=version):
                ops = FakePostGISOperations(version[0])
                actual = ops.spatial_version
                self.assertEqual(version[1:], actual)
    
        def __str__(self):
        'Return OGR GetName and Driver for the Data Source.'
        return '%s (%s)' % (self.name, self.driver)
    
    
# For more information, see the OGR C API source code:
#  https://www.gdal.org/ogr__api_8h.html
#
# The OGR_Fld_* routines are relevant here.
class Field(GDALBase):
    '''
    Wrap an OGR Field. Needs to be instantiated from a Feature object.
    '''
    
            # populate() might be called by two threads in parallel on servers
        # that create threads before initializing the WSGI callable.
        with self._lock:
            if self.ready:
                return
    
    
class RequestsDependencyWarning(RequestsWarning):
    '''An imported dependency doesn't match the expected version range.'''
    pass

    
    import sys
    
    # The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
#
# This is also used if you do content translation via gettext catalogs.
# Usually you set 'language' from the command line for these cases.
language = None
    
    # 'setup.py publish' shortcut.
if sys.argv[-1] == 'publish':
    os.system('python setup.py sdist bdist_wheel')
    os.system('twine upload dist/*')
    sys.exit()
    
        def test_basic_waiting_server(self):
        '''the server waits for the block_server event to be set before closing'''
        block_server = threading.Event()
    
        if cryptography_version < [1, 3, 4]:
        warning = 'Old version of cryptography ({}) may cause slowdown.'.format(cryptography_version)
        warnings.warn(warning, RequestsDependencyWarning)
    
        :param url: URL for the new :class:`Request` object.
    :param data: (optional) Dictionary, list of tuples, bytes, or file-like
        object to send in the body of the :class:`Request`.
    :param json: (optional) json data to send in the body of the :class:`Request`.
    :param \*\*kwargs: Optional arguments that ``request`` takes.
    :return: :class:`Response <Response>` object
    :rtype: requests.Response
    '''
    
        with tf.variable_scope(name, reuse=reuse):
        alpha = get_w(alpha_shape, w_initializer=alpha_init, name='alpha')
        # o = relu(x) + 0.5 * tf.multiply(alpha, x - tf.abs(x))  # TFLearn
        o = leaky_relu(x, alpha)  # TensorLayer / <Deep Learning>
    
            self._built = False
    
        def test_str(self):
        self.assertTrue('FOO' in str(self.error))
        self.assertTrue('{}' in str(self.error))
    
        def encode(self, value):
        if value != self.value:
            logger.warning(
                'Overriding fixed field (%s) with %r', self.json_name, value)
        return value
    
    The JWS implementation in josepy only implements the base JOSE standard. In
order to support the new header fields defined in ACME, this module defines some
ACME-specific classes that layer on top of josepy.
'''
import josepy as jose
    
            self.vhost1 = VirtualHost(
            'filep', 'vh_path', set([self.addr1]), False, False, 'localhost')
    
    from acme import challenges
    
        lineage = domains.split(',')[0]
    server_cert = ssl.get_server_certificate(('localhost', context.tls_alpn_01_port))
    with open(os.path.join(context.workspace, 'conf/live/{0}/cert.pem'.format(lineage)), 'r') as file:
        certbot_cert = file.read()
    
        PREFIX_FREE_DISTRIBUTIONS = [
        'certbot',
        'certbot-apache',
        'certbot-dns-cloudflare',
        'certbot-dns-cloudxns',
        'certbot-dns-digitalocean',
        'certbot-dns-dnsimple',
        'certbot-dns-dnsmadeeasy',
        'certbot-dns-gehirn',
        'certbot-dns-google',
        'certbot-dns-linode',
        'certbot-dns-luadns',
        'certbot-dns-nsone',
        'certbot-dns-ovh',
        'certbot-dns-rfc2136',
        'certbot-dns-route53',
        'certbot-dns-sakuracloud',
        'certbot-nginx',
    ]
    '''Distributions for which prefix will be omitted.'''